{"ast":null,"code":"/**\r\n * negotiator\r\n * Copyright(c) 2012 Isaac Z. Schlueter\r\n * Copyright(c) 2014 Federico Romero\r\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\n'use strict';\n/**\r\n * Module exports.\r\n * @public\r\n */\n\nmodule.exports = preferredEncodings;\nmodule.exports.preferredEncodings = preferredEncodings;\n/**\r\n * Module variables.\r\n * @private\r\n */\n\nvar simpleEncodingRegExp = /^\\s*([^\\s;]+)\\s*(?:;(.*))?$/;\n/**\r\n * Parse the Accept-Encoding header.\r\n * @private\r\n */\n\nfunction parseAcceptEncoding(accept) {\n  var accepts = accept.split(',');\n  var hasIdentity = false;\n  var minQuality = 1;\n\n  for (var i = 0, j = 0; i < accepts.length; i++) {\n    var encoding = parseEncoding(accepts[i].trim(), i);\n\n    if (encoding) {\n      accepts[j++] = encoding;\n      hasIdentity = hasIdentity || specify('identity', encoding);\n      minQuality = Math.min(minQuality, encoding.q || 1);\n    }\n  }\n\n  if (!hasIdentity) {\n    /*\r\n     * If identity doesn't explicitly appear in the accept-encoding header,\r\n     * it's added to the list of acceptable encoding with the lowest q\r\n     */\n    accepts[j++] = {\n      encoding: 'identity',\n      q: minQuality,\n      i: i\n    };\n  } // trim accepts\n\n\n  accepts.length = j;\n  return accepts;\n}\n/**\r\n * Parse an encoding from the Accept-Encoding header.\r\n * @private\r\n */\n\n\nfunction parseEncoding(str, i) {\n  var match = simpleEncodingRegExp.exec(str);\n  if (!match) return null;\n  var encoding = match[1];\n  var q = 1;\n\n  if (match[2]) {\n    var params = match[2].split(';');\n\n    for (var j = 0; j < params.length; j++) {\n      var p = params[j].trim().split('=');\n\n      if (p[0] === 'q') {\n        q = parseFloat(p[1]);\n        break;\n      }\n    }\n  }\n\n  return {\n    encoding: encoding,\n    q: q,\n    i: i\n  };\n}\n/**\r\n * Get the priority of an encoding.\r\n * @private\r\n */\n\n\nfunction getEncodingPriority(encoding, accepted, index) {\n  var priority = {\n    o: -1,\n    q: 0,\n    s: 0\n  };\n\n  for (var i = 0; i < accepted.length; i++) {\n    var spec = specify(encoding, accepted[i], index);\n\n    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {\n      priority = spec;\n    }\n  }\n\n  return priority;\n}\n/**\r\n * Get the specificity of the encoding.\r\n * @private\r\n */\n\n\nfunction specify(encoding, spec, index) {\n  var s = 0;\n\n  if (spec.encoding.toLowerCase() === encoding.toLowerCase()) {\n    s |= 1;\n  } else if (spec.encoding !== '*') {\n    return null;\n  }\n\n  return {\n    i: index,\n    o: spec.i,\n    q: spec.q,\n    s: s\n  };\n}\n\n;\n/**\r\n * Get the preferred encodings from an Accept-Encoding header.\r\n * @public\r\n */\n\nfunction preferredEncodings(accept, provided) {\n  var accepts = parseAcceptEncoding(accept || '');\n\n  if (!provided) {\n    // sorted list of all encodings\n    return accepts.filter(isQuality).sort(compareSpecs).map(getFullEncoding);\n  }\n\n  var priorities = provided.map(function getPriority(type, index) {\n    return getEncodingPriority(type, accepts, index);\n  }); // sorted list of accepted encodings\n\n  return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {\n    return provided[priorities.indexOf(priority)];\n  });\n}\n/**\r\n * Compare two specs.\r\n * @private\r\n */\n\n\nfunction compareSpecs(a, b) {\n  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;\n}\n/**\r\n * Get full encoding string.\r\n * @private\r\n */\n\n\nfunction getFullEncoding(spec) {\n  return spec.encoding;\n}\n/**\r\n * Check if a spec has any quality.\r\n * @private\r\n */\n\n\nfunction isQuality(spec) {\n  return spec.q > 0;\n}","map":{"version":3,"sources":["C:/Users/gabe/Desktop/Pomo/Team5/client/node_modules/negotiator/lib/encoding.js"],"names":["module","exports","preferredEncodings","simpleEncodingRegExp","parseAcceptEncoding","accept","accepts","split","hasIdentity","minQuality","i","j","length","encoding","parseEncoding","trim","specify","Math","min","q","str","match","exec","params","p","parseFloat","getEncodingPriority","accepted","index","priority","o","s","spec","toLowerCase","provided","filter","isQuality","sort","compareSpecs","map","getFullEncoding","priorities","getPriority","type","getEncoding","indexOf","a","b"],"mappings":"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","sourcesContent":["/**\r\n * negotiator\r\n * Copyright(c) 2012 Isaac Z. Schlueter\r\n * Copyright(c) 2014 Federico Romero\r\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\r\n\r\n'use strict';\r\n\r\n/**\r\n * Module exports.\r\n * @public\r\n */\r\n\r\nmodule.exports = preferredEncodings;\r\nmodule.exports.preferredEncodings = preferredEncodings;\r\n\r\n/**\r\n * Module variables.\r\n * @private\r\n */\r\n\r\nvar simpleEncodingRegExp = /^\\s*([^\\s;]+)\\s*(?:;(.*))?$/;\r\n\r\n/**\r\n * Parse the Accept-Encoding header.\r\n * @private\r\n */\r\n\r\nfunction parseAcceptEncoding(accept) {\r\n  var accepts = accept.split(',');\r\n  var hasIdentity = false;\r\n  var minQuality = 1;\r\n\r\n  for (var i = 0, j = 0; i < accepts.length; i++) {\r\n    var encoding = parseEncoding(accepts[i].trim(), i);\r\n\r\n    if (encoding) {\r\n      accepts[j++] = encoding;\r\n      hasIdentity = hasIdentity || specify('identity', encoding);\r\n      minQuality = Math.min(minQuality, encoding.q || 1);\r\n    }\r\n  }\r\n\r\n  if (!hasIdentity) {\r\n    /*\r\n     * If identity doesn't explicitly appear in the accept-encoding header,\r\n     * it's added to the list of acceptable encoding with the lowest q\r\n     */\r\n    accepts[j++] = {\r\n      encoding: 'identity',\r\n      q: minQuality,\r\n      i: i\r\n    };\r\n  }\r\n\r\n  // trim accepts\r\n  accepts.length = j;\r\n\r\n  return accepts;\r\n}\r\n\r\n/**\r\n * Parse an encoding from the Accept-Encoding header.\r\n * @private\r\n */\r\n\r\nfunction parseEncoding(str, i) {\r\n  var match = simpleEncodingRegExp.exec(str);\r\n  if (!match) return null;\r\n\r\n  var encoding = match[1];\r\n  var q = 1;\r\n  if (match[2]) {\r\n    var params = match[2].split(';');\r\n    for (var j = 0; j < params.length; j++) {\r\n      var p = params[j].trim().split('=');\r\n      if (p[0] === 'q') {\r\n        q = parseFloat(p[1]);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    encoding: encoding,\r\n    q: q,\r\n    i: i\r\n  };\r\n}\r\n\r\n/**\r\n * Get the priority of an encoding.\r\n * @private\r\n */\r\n\r\nfunction getEncodingPriority(encoding, accepted, index) {\r\n  var priority = {o: -1, q: 0, s: 0};\r\n\r\n  for (var i = 0; i < accepted.length; i++) {\r\n    var spec = specify(encoding, accepted[i], index);\r\n\r\n    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {\r\n      priority = spec;\r\n    }\r\n  }\r\n\r\n  return priority;\r\n}\r\n\r\n/**\r\n * Get the specificity of the encoding.\r\n * @private\r\n */\r\n\r\nfunction specify(encoding, spec, index) {\r\n  var s = 0;\r\n  if(spec.encoding.toLowerCase() === encoding.toLowerCase()){\r\n    s |= 1;\r\n  } else if (spec.encoding !== '*' ) {\r\n    return null\r\n  }\r\n\r\n  return {\r\n    i: index,\r\n    o: spec.i,\r\n    q: spec.q,\r\n    s: s\r\n  }\r\n};\r\n\r\n/**\r\n * Get the preferred encodings from an Accept-Encoding header.\r\n * @public\r\n */\r\n\r\nfunction preferredEncodings(accept, provided) {\r\n  var accepts = parseAcceptEncoding(accept || '');\r\n\r\n  if (!provided) {\r\n    // sorted list of all encodings\r\n    return accepts\r\n      .filter(isQuality)\r\n      .sort(compareSpecs)\r\n      .map(getFullEncoding);\r\n  }\r\n\r\n  var priorities = provided.map(function getPriority(type, index) {\r\n    return getEncodingPriority(type, accepts, index);\r\n  });\r\n\r\n  // sorted list of accepted encodings\r\n  return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {\r\n    return provided[priorities.indexOf(priority)];\r\n  });\r\n}\r\n\r\n/**\r\n * Compare two specs.\r\n * @private\r\n */\r\n\r\nfunction compareSpecs(a, b) {\r\n  return (b.q - a.q) || (b.s - a.s) || (a.o - b.o) || (a.i - b.i) || 0;\r\n}\r\n\r\n/**\r\n * Get full encoding string.\r\n * @private\r\n */\r\n\r\nfunction getFullEncoding(spec) {\r\n  return spec.encoding;\r\n}\r\n\r\n/**\r\n * Check if a spec has any quality.\r\n * @private\r\n */\r\n\r\nfunction isQuality(spec) {\r\n  return spec.q > 0;\r\n}\r\n"]},"metadata":{},"sourceType":"script"}