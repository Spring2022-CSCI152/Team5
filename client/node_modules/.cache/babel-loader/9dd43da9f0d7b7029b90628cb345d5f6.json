{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RemoteSocket = exports.BroadcastOperator = void 0;\n\nconst socket_1 = require(\"./socket\");\n\nconst socket_io_parser_1 = require(\"socket.io-parser\");\n\nclass BroadcastOperator {\n  constructor(adapter) {\n    let rooms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n    let exceptRooms = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n    let flags = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    this.adapter = adapter;\n    this.rooms = rooms;\n    this.exceptRooms = exceptRooms;\n    this.flags = flags;\n  }\n  /**\r\n   * Targets a room when emitting.\r\n   *\r\n   * @param room\r\n   * @return a new BroadcastOperator instance\r\n   * @public\r\n   */\n\n\n  to(room) {\n    const rooms = new Set(this.rooms);\n\n    if (Array.isArray(room)) {\n      room.forEach(r => rooms.add(r));\n    } else {\n      rooms.add(room);\n    }\n\n    return new BroadcastOperator(this.adapter, rooms, this.exceptRooms, this.flags);\n  }\n  /**\r\n   * Targets a room when emitting.\r\n   *\r\n   * @param room\r\n   * @return a new BroadcastOperator instance\r\n   * @public\r\n   */\n\n\n  in(room) {\n    return this.to(room);\n  }\n  /**\r\n   * Excludes a room when emitting.\r\n   *\r\n   * @param room\r\n   * @return a new BroadcastOperator instance\r\n   * @public\r\n   */\n\n\n  except(room) {\n    const exceptRooms = new Set(this.exceptRooms);\n\n    if (Array.isArray(room)) {\n      room.forEach(r => exceptRooms.add(r));\n    } else {\n      exceptRooms.add(room);\n    }\n\n    return new BroadcastOperator(this.adapter, this.rooms, exceptRooms, this.flags);\n  }\n  /**\r\n   * Sets the compress flag.\r\n   *\r\n   * @param compress - if `true`, compresses the sending data\r\n   * @return a new BroadcastOperator instance\r\n   * @public\r\n   */\n\n\n  compress(compress) {\n    const flags = Object.assign({}, this.flags, {\n      compress\n    });\n    return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n  }\n  /**\r\n   * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\r\n   * receive messages (because of network slowness or other issues, or because they’re connected through long polling\r\n   * and is in the middle of a request-response cycle).\r\n   *\r\n   * @return a new BroadcastOperator instance\r\n   * @public\r\n   */\n\n\n  get volatile() {\n    const flags = Object.assign({}, this.flags, {\n      volatile: true\n    });\n    return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n  }\n  /**\r\n   * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\r\n   *\r\n   * @return a new BroadcastOperator instance\r\n   * @public\r\n   */\n\n\n  get local() {\n    const flags = Object.assign({}, this.flags, {\n      local: true\n    });\n    return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n  }\n  /**\r\n   * Emits to all clients.\r\n   *\r\n   * @return Always true\r\n   * @public\r\n   */\n\n\n  emit(ev) {\n    if (socket_1.RESERVED_EVENTS.has(ev)) {\n      throw new Error(`\"${ev}\" is a reserved event name`);\n    } // set up packet object\n\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    const data = [ev, ...args];\n    const packet = {\n      type: socket_io_parser_1.PacketType.EVENT,\n      data: data\n    };\n\n    if (\"function\" == typeof data[data.length - 1]) {\n      throw new Error(\"Callbacks are not supported when broadcasting\");\n    }\n\n    this.adapter.broadcast(packet, {\n      rooms: this.rooms,\n      except: this.exceptRooms,\n      flags: this.flags\n    });\n    return true;\n  }\n  /**\r\n   * Gets a list of clients.\r\n   *\r\n   * @public\r\n   */\n\n\n  allSockets() {\n    if (!this.adapter) {\n      throw new Error(\"No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?\");\n    }\n\n    return this.adapter.sockets(this.rooms);\n  }\n  /**\r\n   * Returns the matching socket instances\r\n   *\r\n   * @public\r\n   */\n\n\n  fetchSockets() {\n    return this.adapter.fetchSockets({\n      rooms: this.rooms,\n      except: this.exceptRooms\n    }).then(sockets => {\n      return sockets.map(socket => {\n        if (socket instanceof socket_1.Socket) {\n          // FIXME the TypeScript compiler complains about missing private properties\n          return socket;\n        } else {\n          return new RemoteSocket(this.adapter, socket);\n        }\n      });\n    });\n  }\n  /**\r\n   * Makes the matching socket instances join the specified rooms\r\n   *\r\n   * @param room\r\n   * @public\r\n   */\n\n\n  socketsJoin(room) {\n    this.adapter.addSockets({\n      rooms: this.rooms,\n      except: this.exceptRooms\n    }, Array.isArray(room) ? room : [room]);\n  }\n  /**\r\n   * Makes the matching socket instances leave the specified rooms\r\n   *\r\n   * @param room\r\n   * @public\r\n   */\n\n\n  socketsLeave(room) {\n    this.adapter.delSockets({\n      rooms: this.rooms,\n      except: this.exceptRooms\n    }, Array.isArray(room) ? room : [room]);\n  }\n  /**\r\n   * Makes the matching socket instances disconnect\r\n   *\r\n   * @param close - whether to close the underlying connection\r\n   * @public\r\n   */\n\n\n  disconnectSockets() {\n    let close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.adapter.disconnectSockets({\n      rooms: this.rooms,\n      except: this.exceptRooms\n    }, close);\n  }\n\n}\n\nexports.BroadcastOperator = BroadcastOperator;\n/**\r\n * Expose of subset of the attributes and methods of the Socket class\r\n */\n\nclass RemoteSocket {\n  constructor(adapter, details) {\n    this.id = details.id;\n    this.handshake = details.handshake;\n    this.rooms = new Set(details.rooms);\n    this.data = details.data;\n    this.operator = new BroadcastOperator(adapter, new Set([this.id]));\n  }\n\n  emit(ev) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    return this.operator.emit(ev, ...args);\n  }\n  /**\r\n   * Joins a room.\r\n   *\r\n   * @param {String|Array} room - room or array of rooms\r\n   * @public\r\n   */\n\n\n  join(room) {\n    return this.operator.socketsJoin(room);\n  }\n  /**\r\n   * Leaves a room.\r\n   *\r\n   * @param {String} room\r\n   * @public\r\n   */\n\n\n  leave(room) {\n    return this.operator.socketsLeave(room);\n  }\n  /**\r\n   * Disconnects this client.\r\n   *\r\n   * @param {Boolean} close - if `true`, closes the underlying connection\r\n   * @return {Socket} self\r\n   *\r\n   * @public\r\n   */\n\n\n  disconnect() {\n    let close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.operator.disconnectSockets(close);\n    return this;\n  }\n\n}\n\nexports.RemoteSocket = RemoteSocket;","map":{"version":3,"sources":["C:/Users/gabe/Desktop/Pomo/Team5/client/node_modules/socket.io/dist/broadcast-operator.js"],"names":["Object","defineProperty","exports","value","RemoteSocket","BroadcastOperator","socket_1","require","socket_io_parser_1","constructor","adapter","rooms","Set","exceptRooms","flags","to","room","Array","isArray","forEach","r","add","in","except","compress","assign","volatile","local","emit","ev","RESERVED_EVENTS","has","Error","args","data","packet","type","PacketType","EVENT","length","broadcast","allSockets","sockets","fetchSockets","then","map","socket","Socket","socketsJoin","addSockets","socketsLeave","delSockets","disconnectSockets","close","details","id","handshake","operator","join","leave","disconnect"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RemoteSocket = exports.BroadcastOperator = void 0;\r\nconst socket_1 = require(\"./socket\");\r\nconst socket_io_parser_1 = require(\"socket.io-parser\");\r\nclass BroadcastOperator {\r\n    constructor(adapter, rooms = new Set(), exceptRooms = new Set(), flags = {}) {\r\n        this.adapter = adapter;\r\n        this.rooms = rooms;\r\n        this.exceptRooms = exceptRooms;\r\n        this.flags = flags;\r\n    }\r\n    /**\r\n     * Targets a room when emitting.\r\n     *\r\n     * @param room\r\n     * @return a new BroadcastOperator instance\r\n     * @public\r\n     */\r\n    to(room) {\r\n        const rooms = new Set(this.rooms);\r\n        if (Array.isArray(room)) {\r\n            room.forEach((r) => rooms.add(r));\r\n        }\r\n        else {\r\n            rooms.add(room);\r\n        }\r\n        return new BroadcastOperator(this.adapter, rooms, this.exceptRooms, this.flags);\r\n    }\r\n    /**\r\n     * Targets a room when emitting.\r\n     *\r\n     * @param room\r\n     * @return a new BroadcastOperator instance\r\n     * @public\r\n     */\r\n    in(room) {\r\n        return this.to(room);\r\n    }\r\n    /**\r\n     * Excludes a room when emitting.\r\n     *\r\n     * @param room\r\n     * @return a new BroadcastOperator instance\r\n     * @public\r\n     */\r\n    except(room) {\r\n        const exceptRooms = new Set(this.exceptRooms);\r\n        if (Array.isArray(room)) {\r\n            room.forEach((r) => exceptRooms.add(r));\r\n        }\r\n        else {\r\n            exceptRooms.add(room);\r\n        }\r\n        return new BroadcastOperator(this.adapter, this.rooms, exceptRooms, this.flags);\r\n    }\r\n    /**\r\n     * Sets the compress flag.\r\n     *\r\n     * @param compress - if `true`, compresses the sending data\r\n     * @return a new BroadcastOperator instance\r\n     * @public\r\n     */\r\n    compress(compress) {\r\n        const flags = Object.assign({}, this.flags, { compress });\r\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\r\n    }\r\n    /**\r\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\r\n     * receive messages (because of network slowness or other issues, or because they’re connected through long polling\r\n     * and is in the middle of a request-response cycle).\r\n     *\r\n     * @return a new BroadcastOperator instance\r\n     * @public\r\n     */\r\n    get volatile() {\r\n        const flags = Object.assign({}, this.flags, { volatile: true });\r\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\r\n    }\r\n    /**\r\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\r\n     *\r\n     * @return a new BroadcastOperator instance\r\n     * @public\r\n     */\r\n    get local() {\r\n        const flags = Object.assign({}, this.flags, { local: true });\r\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\r\n    }\r\n    /**\r\n     * Emits to all clients.\r\n     *\r\n     * @return Always true\r\n     * @public\r\n     */\r\n    emit(ev, ...args) {\r\n        if (socket_1.RESERVED_EVENTS.has(ev)) {\r\n            throw new Error(`\"${ev}\" is a reserved event name`);\r\n        }\r\n        // set up packet object\r\n        const data = [ev, ...args];\r\n        const packet = {\r\n            type: socket_io_parser_1.PacketType.EVENT,\r\n            data: data,\r\n        };\r\n        if (\"function\" == typeof data[data.length - 1]) {\r\n            throw new Error(\"Callbacks are not supported when broadcasting\");\r\n        }\r\n        this.adapter.broadcast(packet, {\r\n            rooms: this.rooms,\r\n            except: this.exceptRooms,\r\n            flags: this.flags,\r\n        });\r\n        return true;\r\n    }\r\n    /**\r\n     * Gets a list of clients.\r\n     *\r\n     * @public\r\n     */\r\n    allSockets() {\r\n        if (!this.adapter) {\r\n            throw new Error(\"No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?\");\r\n        }\r\n        return this.adapter.sockets(this.rooms);\r\n    }\r\n    /**\r\n     * Returns the matching socket instances\r\n     *\r\n     * @public\r\n     */\r\n    fetchSockets() {\r\n        return this.adapter\r\n            .fetchSockets({\r\n            rooms: this.rooms,\r\n            except: this.exceptRooms,\r\n        })\r\n            .then((sockets) => {\r\n            return sockets.map((socket) => {\r\n                if (socket instanceof socket_1.Socket) {\r\n                    // FIXME the TypeScript compiler complains about missing private properties\r\n                    return socket;\r\n                }\r\n                else {\r\n                    return new RemoteSocket(this.adapter, socket);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Makes the matching socket instances join the specified rooms\r\n     *\r\n     * @param room\r\n     * @public\r\n     */\r\n    socketsJoin(room) {\r\n        this.adapter.addSockets({\r\n            rooms: this.rooms,\r\n            except: this.exceptRooms,\r\n        }, Array.isArray(room) ? room : [room]);\r\n    }\r\n    /**\r\n     * Makes the matching socket instances leave the specified rooms\r\n     *\r\n     * @param room\r\n     * @public\r\n     */\r\n    socketsLeave(room) {\r\n        this.adapter.delSockets({\r\n            rooms: this.rooms,\r\n            except: this.exceptRooms,\r\n        }, Array.isArray(room) ? room : [room]);\r\n    }\r\n    /**\r\n     * Makes the matching socket instances disconnect\r\n     *\r\n     * @param close - whether to close the underlying connection\r\n     * @public\r\n     */\r\n    disconnectSockets(close = false) {\r\n        this.adapter.disconnectSockets({\r\n            rooms: this.rooms,\r\n            except: this.exceptRooms,\r\n        }, close);\r\n    }\r\n}\r\nexports.BroadcastOperator = BroadcastOperator;\r\n/**\r\n * Expose of subset of the attributes and methods of the Socket class\r\n */\r\nclass RemoteSocket {\r\n    constructor(adapter, details) {\r\n        this.id = details.id;\r\n        this.handshake = details.handshake;\r\n        this.rooms = new Set(details.rooms);\r\n        this.data = details.data;\r\n        this.operator = new BroadcastOperator(adapter, new Set([this.id]));\r\n    }\r\n    emit(ev, ...args) {\r\n        return this.operator.emit(ev, ...args);\r\n    }\r\n    /**\r\n     * Joins a room.\r\n     *\r\n     * @param {String|Array} room - room or array of rooms\r\n     * @public\r\n     */\r\n    join(room) {\r\n        return this.operator.socketsJoin(room);\r\n    }\r\n    /**\r\n     * Leaves a room.\r\n     *\r\n     * @param {String} room\r\n     * @public\r\n     */\r\n    leave(room) {\r\n        return this.operator.socketsLeave(room);\r\n    }\r\n    /**\r\n     * Disconnects this client.\r\n     *\r\n     * @param {Boolean} close - if `true`, closes the underlying connection\r\n     * @return {Socket} self\r\n     *\r\n     * @public\r\n     */\r\n    disconnect(close = false) {\r\n        this.operator.disconnectSockets(close);\r\n        return this;\r\n    }\r\n}\r\nexports.RemoteSocket = RemoteSocket;\r\n"]},"metadata":{},"sourceType":"script"}