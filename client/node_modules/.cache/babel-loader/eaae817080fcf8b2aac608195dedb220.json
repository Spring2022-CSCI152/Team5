{"ast":null,"code":"/*!\r\n * base64id v0.1.0\r\n */\n\n/**\r\n * Module dependencies\r\n */\nvar crypto = require('crypto');\n/**\r\n * Constructor\r\n */\n\n\nvar Base64Id = function () {};\n/**\r\n * Get random bytes\r\n *\r\n * Uses a buffer if available, falls back to crypto.randomBytes\r\n */\n\n\nBase64Id.prototype.getRandomBytes = function (bytes) {\n  var BUFFER_SIZE = 4096;\n  var self = this;\n  bytes = bytes || 12;\n\n  if (bytes > BUFFER_SIZE) {\n    return crypto.randomBytes(bytes);\n  }\n\n  var bytesInBuffer = parseInt(BUFFER_SIZE / bytes);\n  var threshold = parseInt(bytesInBuffer * 0.85);\n\n  if (!threshold) {\n    return crypto.randomBytes(bytes);\n  }\n\n  if (this.bytesBufferIndex == null) {\n    this.bytesBufferIndex = -1;\n  }\n\n  if (this.bytesBufferIndex == bytesInBuffer) {\n    this.bytesBuffer = null;\n    this.bytesBufferIndex = -1;\n  } // No buffered bytes available or index above threshold\n\n\n  if (this.bytesBufferIndex == -1 || this.bytesBufferIndex > threshold) {\n    if (!this.isGeneratingBytes) {\n      this.isGeneratingBytes = true;\n      crypto.randomBytes(BUFFER_SIZE, function (err, bytes) {\n        self.bytesBuffer = bytes;\n        self.bytesBufferIndex = 0;\n        self.isGeneratingBytes = false;\n      });\n    } // Fall back to sync call when no buffered bytes are available\n\n\n    if (this.bytesBufferIndex == -1) {\n      return crypto.randomBytes(bytes);\n    }\n  }\n\n  var result = this.bytesBuffer.slice(bytes * this.bytesBufferIndex, bytes * (this.bytesBufferIndex + 1));\n  this.bytesBufferIndex++;\n  return result;\n};\n/**\r\n * Generates a base64 id\r\n *\r\n * (Original version from socket.io <http://socket.io>)\r\n */\n\n\nBase64Id.prototype.generateId = function () {\n  var rand = Buffer.alloc(15); // multiple of 3 for base64\n\n  if (!rand.writeInt32BE) {\n    return Math.abs(Math.random() * Math.random() * Date.now() | 0).toString() + Math.abs(Math.random() * Math.random() * Date.now() | 0).toString();\n  }\n\n  this.sequenceNumber = this.sequenceNumber + 1 | 0;\n  rand.writeInt32BE(this.sequenceNumber, 11);\n\n  if (crypto.randomBytes) {\n    this.getRandomBytes(12).copy(rand);\n  } else {\n    // not secure for node 0.4\n    [0, 4, 8].forEach(function (i) {\n      rand.writeInt32BE(Math.random() * Math.pow(2, 32) | 0, i);\n    });\n  }\n\n  return rand.toString('base64').replace(/\\//g, '_').replace(/\\+/g, '-');\n};\n/**\r\n * Export\r\n */\n\n\nexports = module.exports = new Base64Id();","map":{"version":3,"sources":["C:/Users/gabe/Desktop/Pomo/Team5/client/node_modules/base64id/lib/base64id.js"],"names":["crypto","require","Base64Id","prototype","getRandomBytes","bytes","BUFFER_SIZE","self","randomBytes","bytesInBuffer","parseInt","threshold","bytesBufferIndex","bytesBuffer","isGeneratingBytes","err","result","slice","generateId","rand","Buffer","alloc","writeInt32BE","Math","abs","random","Date","now","toString","sequenceNumber","copy","forEach","i","pow","replace","exports","module"],"mappings":"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","sourcesContent":["/*!\r\n * base64id v0.1.0\r\n */\r\n\r\n/**\r\n * Module dependencies\r\n */\r\n\r\nvar crypto = require('crypto');\r\n\r\n/**\r\n * Constructor\r\n */\r\n\r\nvar Base64Id = function() { };\r\n\r\n/**\r\n * Get random bytes\r\n *\r\n * Uses a buffer if available, falls back to crypto.randomBytes\r\n */\r\n\r\nBase64Id.prototype.getRandomBytes = function(bytes) {\r\n\r\n  var BUFFER_SIZE = 4096\r\n  var self = this;  \r\n  \r\n  bytes = bytes || 12;\r\n\r\n  if (bytes > BUFFER_SIZE) {\r\n    return crypto.randomBytes(bytes);\r\n  }\r\n  \r\n  var bytesInBuffer = parseInt(BUFFER_SIZE/bytes);\r\n  var threshold = parseInt(bytesInBuffer*0.85);\r\n\r\n  if (!threshold) {\r\n    return crypto.randomBytes(bytes);\r\n  }\r\n\r\n  if (this.bytesBufferIndex == null) {\r\n     this.bytesBufferIndex = -1;\r\n  }\r\n\r\n  if (this.bytesBufferIndex == bytesInBuffer) {\r\n    this.bytesBuffer = null;\r\n    this.bytesBufferIndex = -1;\r\n  }\r\n\r\n  // No buffered bytes available or index above threshold\r\n  if (this.bytesBufferIndex == -1 || this.bytesBufferIndex > threshold) {\r\n     \r\n    if (!this.isGeneratingBytes) {\r\n      this.isGeneratingBytes = true;\r\n      crypto.randomBytes(BUFFER_SIZE, function(err, bytes) {\r\n        self.bytesBuffer = bytes;\r\n        self.bytesBufferIndex = 0;\r\n        self.isGeneratingBytes = false;\r\n      }); \r\n    }\r\n    \r\n    // Fall back to sync call when no buffered bytes are available\r\n    if (this.bytesBufferIndex == -1) {\r\n      return crypto.randomBytes(bytes);\r\n    }\r\n  }\r\n  \r\n  var result = this.bytesBuffer.slice(bytes*this.bytesBufferIndex, bytes*(this.bytesBufferIndex+1)); \r\n  this.bytesBufferIndex++; \r\n  \r\n  return result;\r\n}\r\n\r\n/**\r\n * Generates a base64 id\r\n *\r\n * (Original version from socket.io <http://socket.io>)\r\n */\r\n\r\nBase64Id.prototype.generateId = function () {\r\n  var rand = Buffer.alloc(15); // multiple of 3 for base64\r\n  if (!rand.writeInt32BE) {\r\n    return Math.abs(Math.random() * Math.random() * Date.now() | 0).toString()\r\n      + Math.abs(Math.random() * Math.random() * Date.now() | 0).toString();\r\n  }\r\n  this.sequenceNumber = (this.sequenceNumber + 1) | 0;\r\n  rand.writeInt32BE(this.sequenceNumber, 11);\r\n  if (crypto.randomBytes) {\r\n    this.getRandomBytes(12).copy(rand);\r\n  } else {\r\n    // not secure for node 0.4\r\n    [0, 4, 8].forEach(function(i) {\r\n      rand.writeInt32BE(Math.random() * Math.pow(2, 32) | 0, i);\r\n    });\r\n  }\r\n  return rand.toString('base64').replace(/\\//g, '_').replace(/\\+/g, '-');\r\n};\r\n\r\n/**\r\n * Export\r\n */\r\n\r\nexports = module.exports = new Base64Id();\r\n"]},"metadata":{},"sourceType":"script"}