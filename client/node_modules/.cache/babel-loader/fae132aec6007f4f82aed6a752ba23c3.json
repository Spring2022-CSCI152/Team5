{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.uServer = void 0;\n\nconst debug_1 = require(\"debug\");\n\nconst server_1 = require(\"./server\");\n\nconst transports_uws_1 = require(\"./transports-uws\");\n\nconst debug = (0, debug_1.default)(\"engine:uws\");\n\nclass uServer extends server_1.BaseServer {\n  init() {}\n\n  cleanup() {}\n  /**\r\n   * Prepares a request by processing the query string.\r\n   *\r\n   * @api private\r\n   */\n\n\n  prepare(req, res) {\n    req.method = req.getMethod().toUpperCase();\n    const params = new URLSearchParams(req.getQuery());\n    req._query = Object.fromEntries(params.entries());\n    req.headers = {};\n    req.forEach((key, value) => {\n      req.headers[key] = value;\n    });\n    req.connection = {\n      remoteAddress: Buffer.from(res.getRemoteAddressAsText()).toString()\n    };\n    res.onAborted(() => {\n      debug(\"response has been aborted\");\n    });\n  }\n\n  createTransport(transportName, req) {\n    return new transports_uws_1.default[transportName](req);\n  }\n  /**\r\n   * Attach the engine to a ÂµWebSockets.js server\r\n   * @param app\r\n   * @param options\r\n   */\n\n\n  attach(app\n  /* : TemplatedApp */\n  ) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const path = (options.path || \"/engine.io\").replace(/\\/$/, \"\") + \"/\";\n    app.any(path, this.handleRequest.bind(this)) //\n    .ws(path, {\n      compression: options.compression,\n      idleTimeout: options.idleTimeout,\n      maxBackpressure: options.maxBackpressure,\n      maxPayloadLength: this.opts.maxHttpBufferSize,\n      upgrade: this.handleUpgrade.bind(this),\n      open: ws => {\n        ws.transport.socket = ws;\n        ws.transport.writable = true;\n        ws.transport.emit(\"drain\");\n      },\n      message: (ws, message, isBinary) => {\n        ws.transport.onData(isBinary ? message : Buffer.from(message).toString());\n      },\n      close: (ws, code, message) => {\n        ws.transport.onClose(code, message);\n      }\n    });\n  }\n\n  handleRequest(res, req) {\n    debug('handling \"%s\" http request \"%s\"', req.getMethod(), req.getUrl());\n    this.prepare(req, res);\n    req.res = res;\n\n    const callback = (errorCode, errorContext) => {\n      if (errorCode !== undefined) {\n        this.emit(\"connection_error\", {\n          req,\n          code: errorCode,\n          message: server_1.Server.errorMessages[errorCode],\n          context: errorContext\n        });\n        this.abortRequest(req.res, errorCode, errorContext);\n        return;\n      }\n\n      if (req._query.sid) {\n        debug(\"setting new request for existing client\");\n\n        this.clients[req._query.sid].transport.onRequest(req);\n      } else {\n        const closeConnection = (errorCode, errorContext) => this.abortRequest(res, errorCode, errorContext);\n\n        this.handshake(req._query.transport, req, closeConnection);\n      }\n    };\n\n    if (this.corsMiddleware) {\n      // needed to buffer headers until the status is computed\n      req.res = new ResponseWrapper(res);\n      this.corsMiddleware.call(null, req, req.res, () => {\n        this.verify(req, false, callback);\n      });\n    } else {\n      this.verify(req, false, callback);\n    }\n  }\n\n  handleUpgrade(res, req, context) {\n    debug(\"on upgrade\");\n    this.prepare(req, res); // @ts-ignore\n\n    req.res = res;\n    this.verify(req, true, async (errorCode, errorContext) => {\n      if (errorCode) {\n        this.emit(\"connection_error\", {\n          req,\n          code: errorCode,\n          message: server_1.Server.errorMessages[errorCode],\n          context: errorContext\n        });\n        this.abortRequest(res, errorCode, errorContext);\n        return;\n      }\n\n      const id = req._query.sid;\n      let transport;\n\n      if (id) {\n        const client = this.clients[id];\n\n        if (!client) {\n          debug(\"upgrade attempt for closed client\");\n          res.close();\n        } else if (client.upgrading) {\n          debug(\"transport has already been trying to upgrade\");\n          res.close();\n        } else if (client.upgraded) {\n          debug(\"transport had already been upgraded\");\n          res.close();\n        } else {\n          debug(\"upgrading existing transport\");\n          transport = this.createTransport(req._query.transport, req);\n          client.maybeUpgrade(transport);\n        }\n      } else {\n        transport = await this.handshake(req._query.transport, req, (errorCode, errorContext) => this.abortRequest(res, errorCode, errorContext));\n\n        if (!transport) {\n          return;\n        }\n      }\n\n      res.upgrade({\n        transport\n      }, req.getHeader(\"sec-websocket-key\"), req.getHeader(\"sec-websocket-protocol\"), req.getHeader(\"sec-websocket-extensions\"), context);\n    });\n  }\n\n  abortRequest(res, errorCode, errorContext) {\n    const statusCode = errorCode === server_1.Server.errors.FORBIDDEN ? \"403 Forbidden\" : \"400 Bad Request\";\n    const message = errorContext && errorContext.message ? errorContext.message : server_1.Server.errorMessages[errorCode];\n    res.writeStatus(statusCode);\n    res.writeHeader(\"Content-Type\", \"application/json\");\n    res.end(JSON.stringify({\n      code: errorCode,\n      message\n    }));\n  }\n\n}\n\nexports.uServer = uServer;\n\nclass ResponseWrapper {\n  constructor(res) {\n    this.res = res;\n    this.statusWritten = false;\n    this.headers = [];\n  }\n\n  set statusCode(status) {\n    this.writeStatus(status === 200 ? \"200 OK\" : \"204 No Content\");\n  }\n\n  setHeader(key, value) {\n    this.writeHeader(key, value);\n  } // needed by vary: https://github.com/jshttp/vary/blob/5d725d059b3871025cf753e9dfa08924d0bcfa8f/index.js#L134\n\n\n  getHeader() {}\n\n  writeStatus(status) {\n    this.res.writeStatus(status);\n    this.statusWritten = true;\n    this.writeBufferedHeaders();\n  }\n\n  writeHeader(key, value) {\n    if (key === \"Content-Length\") {\n      // the content length is automatically added by uWebSockets.js\n      return;\n    }\n\n    if (this.statusWritten) {\n      this.res.writeHeader(key, value);\n    } else {\n      this.headers.push([key, value]);\n    }\n  }\n\n  writeBufferedHeaders() {\n    this.headers.forEach(_ref => {\n      let [key, value] = _ref;\n      this.res.writeHeader(key, value);\n    });\n  }\n\n  end(data) {\n    if (!this.statusWritten) {\n      // status will be inferred as \"200 OK\"\n      this.writeBufferedHeaders();\n    }\n\n    this.res.end(data);\n  }\n\n  onData(fn) {\n    this.res.onData(fn);\n  }\n\n  onAborted(fn) {\n    this.res.onAborted(fn);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/gabe/Desktop/Pomo/Team5/client/node_modules/engine.io/build/userver.js"],"names":["Object","defineProperty","exports","value","uServer","debug_1","require","server_1","transports_uws_1","debug","default","BaseServer","init","cleanup","prepare","req","res","method","getMethod","toUpperCase","params","URLSearchParams","getQuery","_query","fromEntries","entries","headers","forEach","key","connection","remoteAddress","Buffer","from","getRemoteAddressAsText","toString","onAborted","createTransport","transportName","attach","app","options","path","replace","any","handleRequest","bind","ws","compression","idleTimeout","maxBackpressure","maxPayloadLength","opts","maxHttpBufferSize","upgrade","handleUpgrade","open","transport","socket","writable","emit","message","isBinary","onData","close","code","onClose","getUrl","callback","errorCode","errorContext","undefined","Server","errorMessages","context","abortRequest","sid","clients","onRequest","closeConnection","handshake","corsMiddleware","ResponseWrapper","call","verify","id","client","upgrading","upgraded","maybeUpgrade","getHeader","statusCode","errors","FORBIDDEN","writeStatus","writeHeader","end","JSON","stringify","constructor","statusWritten","status","setHeader","writeBufferedHeaders","push","data","fn"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.uServer = void 0;\r\nconst debug_1 = require(\"debug\");\r\nconst server_1 = require(\"./server\");\r\nconst transports_uws_1 = require(\"./transports-uws\");\r\nconst debug = (0, debug_1.default)(\"engine:uws\");\r\nclass uServer extends server_1.BaseServer {\r\n    init() { }\r\n    cleanup() { }\r\n    /**\r\n     * Prepares a request by processing the query string.\r\n     *\r\n     * @api private\r\n     */\r\n    prepare(req, res) {\r\n        req.method = req.getMethod().toUpperCase();\r\n        const params = new URLSearchParams(req.getQuery());\r\n        req._query = Object.fromEntries(params.entries());\r\n        req.headers = {};\r\n        req.forEach((key, value) => {\r\n            req.headers[key] = value;\r\n        });\r\n        req.connection = {\r\n            remoteAddress: Buffer.from(res.getRemoteAddressAsText()).toString()\r\n        };\r\n        res.onAborted(() => {\r\n            debug(\"response has been aborted\");\r\n        });\r\n    }\r\n    createTransport(transportName, req) {\r\n        return new transports_uws_1.default[transportName](req);\r\n    }\r\n    /**\r\n     * Attach the engine to a ÂµWebSockets.js server\r\n     * @param app\r\n     * @param options\r\n     */\r\n    attach(app /* : TemplatedApp */, options = {}) {\r\n        const path = (options.path || \"/engine.io\").replace(/\\/$/, \"\") + \"/\";\r\n        app\r\n            .any(path, this.handleRequest.bind(this))\r\n            //\r\n            .ws(path, {\r\n            compression: options.compression,\r\n            idleTimeout: options.idleTimeout,\r\n            maxBackpressure: options.maxBackpressure,\r\n            maxPayloadLength: this.opts.maxHttpBufferSize,\r\n            upgrade: this.handleUpgrade.bind(this),\r\n            open: ws => {\r\n                ws.transport.socket = ws;\r\n                ws.transport.writable = true;\r\n                ws.transport.emit(\"drain\");\r\n            },\r\n            message: (ws, message, isBinary) => {\r\n                ws.transport.onData(isBinary ? message : Buffer.from(message).toString());\r\n            },\r\n            close: (ws, code, message) => {\r\n                ws.transport.onClose(code, message);\r\n            }\r\n        });\r\n    }\r\n    handleRequest(res, req) {\r\n        debug('handling \"%s\" http request \"%s\"', req.getMethod(), req.getUrl());\r\n        this.prepare(req, res);\r\n        req.res = res;\r\n        const callback = (errorCode, errorContext) => {\r\n            if (errorCode !== undefined) {\r\n                this.emit(\"connection_error\", {\r\n                    req,\r\n                    code: errorCode,\r\n                    message: server_1.Server.errorMessages[errorCode],\r\n                    context: errorContext\r\n                });\r\n                this.abortRequest(req.res, errorCode, errorContext);\r\n                return;\r\n            }\r\n            if (req._query.sid) {\r\n                debug(\"setting new request for existing client\");\r\n                this.clients[req._query.sid].transport.onRequest(req);\r\n            }\r\n            else {\r\n                const closeConnection = (errorCode, errorContext) => this.abortRequest(res, errorCode, errorContext);\r\n                this.handshake(req._query.transport, req, closeConnection);\r\n            }\r\n        };\r\n        if (this.corsMiddleware) {\r\n            // needed to buffer headers until the status is computed\r\n            req.res = new ResponseWrapper(res);\r\n            this.corsMiddleware.call(null, req, req.res, () => {\r\n                this.verify(req, false, callback);\r\n            });\r\n        }\r\n        else {\r\n            this.verify(req, false, callback);\r\n        }\r\n    }\r\n    handleUpgrade(res, req, context) {\r\n        debug(\"on upgrade\");\r\n        this.prepare(req, res);\r\n        // @ts-ignore\r\n        req.res = res;\r\n        this.verify(req, true, async (errorCode, errorContext) => {\r\n            if (errorCode) {\r\n                this.emit(\"connection_error\", {\r\n                    req,\r\n                    code: errorCode,\r\n                    message: server_1.Server.errorMessages[errorCode],\r\n                    context: errorContext\r\n                });\r\n                this.abortRequest(res, errorCode, errorContext);\r\n                return;\r\n            }\r\n            const id = req._query.sid;\r\n            let transport;\r\n            if (id) {\r\n                const client = this.clients[id];\r\n                if (!client) {\r\n                    debug(\"upgrade attempt for closed client\");\r\n                    res.close();\r\n                }\r\n                else if (client.upgrading) {\r\n                    debug(\"transport has already been trying to upgrade\");\r\n                    res.close();\r\n                }\r\n                else if (client.upgraded) {\r\n                    debug(\"transport had already been upgraded\");\r\n                    res.close();\r\n                }\r\n                else {\r\n                    debug(\"upgrading existing transport\");\r\n                    transport = this.createTransport(req._query.transport, req);\r\n                    client.maybeUpgrade(transport);\r\n                }\r\n            }\r\n            else {\r\n                transport = await this.handshake(req._query.transport, req, (errorCode, errorContext) => this.abortRequest(res, errorCode, errorContext));\r\n                if (!transport) {\r\n                    return;\r\n                }\r\n            }\r\n            res.upgrade({\r\n                transport\r\n            }, req.getHeader(\"sec-websocket-key\"), req.getHeader(\"sec-websocket-protocol\"), req.getHeader(\"sec-websocket-extensions\"), context);\r\n        });\r\n    }\r\n    abortRequest(res, errorCode, errorContext) {\r\n        const statusCode = errorCode === server_1.Server.errors.FORBIDDEN\r\n            ? \"403 Forbidden\"\r\n            : \"400 Bad Request\";\r\n        const message = errorContext && errorContext.message\r\n            ? errorContext.message\r\n            : server_1.Server.errorMessages[errorCode];\r\n        res.writeStatus(statusCode);\r\n        res.writeHeader(\"Content-Type\", \"application/json\");\r\n        res.end(JSON.stringify({\r\n            code: errorCode,\r\n            message\r\n        }));\r\n    }\r\n}\r\nexports.uServer = uServer;\r\nclass ResponseWrapper {\r\n    constructor(res) {\r\n        this.res = res;\r\n        this.statusWritten = false;\r\n        this.headers = [];\r\n    }\r\n    set statusCode(status) {\r\n        this.writeStatus(status === 200 ? \"200 OK\" : \"204 No Content\");\r\n    }\r\n    setHeader(key, value) {\r\n        this.writeHeader(key, value);\r\n    }\r\n    // needed by vary: https://github.com/jshttp/vary/blob/5d725d059b3871025cf753e9dfa08924d0bcfa8f/index.js#L134\r\n    getHeader() { }\r\n    writeStatus(status) {\r\n        this.res.writeStatus(status);\r\n        this.statusWritten = true;\r\n        this.writeBufferedHeaders();\r\n    }\r\n    writeHeader(key, value) {\r\n        if (key === \"Content-Length\") {\r\n            // the content length is automatically added by uWebSockets.js\r\n            return;\r\n        }\r\n        if (this.statusWritten) {\r\n            this.res.writeHeader(key, value);\r\n        }\r\n        else {\r\n            this.headers.push([key, value]);\r\n        }\r\n    }\r\n    writeBufferedHeaders() {\r\n        this.headers.forEach(([key, value]) => {\r\n            this.res.writeHeader(key, value);\r\n        });\r\n    }\r\n    end(data) {\r\n        if (!this.statusWritten) {\r\n            // status will be inferred as \"200 OK\"\r\n            this.writeBufferedHeaders();\r\n        }\r\n        this.res.end(data);\r\n    }\r\n    onData(fn) {\r\n        this.res.onData(fn);\r\n    }\r\n    onAborted(fn) {\r\n        this.res.onAborted(fn);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}