{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Server = exports.BaseServer = void 0;\n\nconst qs = require(\"querystring\");\n\nconst url_1 = require(\"url\");\n\nconst base64id = require(\"base64id\");\n\nconst transports_1 = require(\"./transports\");\n\nconst events_1 = require(\"events\");\n\nconst socket_1 = require(\"./socket\");\n\nconst debug_1 = require(\"debug\");\n\nconst cookie_1 = require(\"cookie\");\n\nconst ws_1 = require(\"ws\");\n\nconst debug = (0, debug_1.default)(\"engine\");\n\nclass BaseServer extends events_1.EventEmitter {\n  /**\r\n   * Server constructor.\r\n   *\r\n   * @param {Object} opts - options\r\n   * @api public\r\n   */\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this.clients = {};\n    this.clientsCount = 0;\n    this.opts = Object.assign({\n      wsEngine: ws_1.Server,\n      pingTimeout: 20000,\n      pingInterval: 25000,\n      upgradeTimeout: 10000,\n      maxHttpBufferSize: 1e6,\n      transports: Object.keys(transports_1.default),\n      allowUpgrades: true,\n      httpCompression: {\n        threshold: 1024\n      },\n      cors: false,\n      allowEIO3: false\n    }, opts);\n\n    if (opts.cookie) {\n      this.opts.cookie = Object.assign({\n        name: \"io\",\n        path: \"/\",\n        // @ts-ignore\n        httpOnly: opts.cookie.path !== false,\n        sameSite: \"lax\"\n      }, opts.cookie);\n    }\n\n    if (this.opts.cors) {\n      this.corsMiddleware = require(\"cors\")(this.opts.cors);\n    }\n\n    if (opts.perMessageDeflate) {\n      this.opts.perMessageDeflate = Object.assign({\n        threshold: 1024\n      }, opts.perMessageDeflate);\n    }\n\n    this.init();\n  }\n  /**\r\n   * Returns a list of available transports for upgrade given a certain transport.\r\n   *\r\n   * @return {Array}\r\n   * @api public\r\n   */\n\n\n  upgrades(transport) {\n    if (!this.opts.allowUpgrades) return [];\n    return transports_1.default[transport].upgradesTo || [];\n  }\n  /**\r\n   * Verifies a request.\r\n   *\r\n   * @param {http.IncomingMessage}\r\n   * @return {Boolean} whether the request is valid\r\n   * @api private\r\n   */\n\n\n  verify(req, upgrade, fn) {\n    // transport check\n    const transport = req._query.transport;\n\n    if (!~this.opts.transports.indexOf(transport)) {\n      debug('unknown transport \"%s\"', transport);\n      return fn(Server.errors.UNKNOWN_TRANSPORT, {\n        transport\n      });\n    } // 'Origin' header check\n\n\n    const isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);\n\n    if (isOriginInvalid) {\n      const origin = req.headers.origin;\n      req.headers.origin = null;\n      debug(\"origin header invalid\");\n      return fn(Server.errors.BAD_REQUEST, {\n        name: \"INVALID_ORIGIN\",\n        origin\n      });\n    } // sid check\n\n\n    const sid = req._query.sid;\n\n    if (sid) {\n      if (!this.clients.hasOwnProperty(sid)) {\n        debug('unknown sid \"%s\"', sid);\n        return fn(Server.errors.UNKNOWN_SID, {\n          sid\n        });\n      }\n\n      const previousTransport = this.clients[sid].transport.name;\n\n      if (!upgrade && previousTransport !== transport) {\n        debug(\"bad request: unexpected transport without upgrade\");\n        return fn(Server.errors.BAD_REQUEST, {\n          name: \"TRANSPORT_MISMATCH\",\n          transport,\n          previousTransport\n        });\n      }\n    } else {\n      // handshake is GET only\n      if (\"GET\" !== req.method) {\n        return fn(Server.errors.BAD_HANDSHAKE_METHOD, {\n          method: req.method\n        });\n      }\n\n      if (transport === \"websocket\" && !upgrade) {\n        debug(\"invalid transport upgrade\");\n        return fn(Server.errors.BAD_REQUEST, {\n          name: \"TRANSPORT_HANDSHAKE_ERROR\"\n        });\n      }\n\n      if (!this.opts.allowRequest) return fn();\n      return this.opts.allowRequest(req, (message, success) => {\n        if (!success) {\n          return fn(Server.errors.FORBIDDEN, {\n            message\n          });\n        }\n\n        fn();\n      });\n    }\n\n    fn();\n  }\n  /**\r\n   * Closes all clients.\r\n   *\r\n   * @api public\r\n   */\n\n\n  close() {\n    debug(\"closing all open clients\");\n\n    for (let i in this.clients) {\n      if (this.clients.hasOwnProperty(i)) {\n        this.clients[i].close(true);\n      }\n    }\n\n    this.cleanup();\n    return this;\n  }\n  /**\r\n   * generate a socket id.\r\n   * Overwrite this method to generate your custom socket id\r\n   *\r\n   * @param {Object} request object\r\n   * @api public\r\n   */\n\n\n  generateId(req) {\n    return base64id.generateId();\n  }\n  /**\r\n   * Handshakes a new client.\r\n   *\r\n   * @param {String} transport name\r\n   * @param {Object} request object\r\n   * @param {Function} closeConnection\r\n   *\r\n   * @api protected\r\n   */\n\n\n  async handshake(transportName, req, closeConnection) {\n    const protocol = req._query.EIO === \"4\" ? 4 : 3; // 3rd revision by default\n\n    if (protocol === 3 && !this.opts.allowEIO3) {\n      debug(\"unsupported protocol version\");\n      this.emit(\"connection_error\", {\n        req,\n        code: Server.errors.UNSUPPORTED_PROTOCOL_VERSION,\n        message: Server.errorMessages[Server.errors.UNSUPPORTED_PROTOCOL_VERSION],\n        context: {\n          protocol\n        }\n      });\n      closeConnection(Server.errors.UNSUPPORTED_PROTOCOL_VERSION);\n      return;\n    }\n\n    let id;\n\n    try {\n      id = await this.generateId(req);\n    } catch (e) {\n      debug(\"error while generating an id\");\n      this.emit(\"connection_error\", {\n        req,\n        code: Server.errors.BAD_REQUEST,\n        message: Server.errorMessages[Server.errors.BAD_REQUEST],\n        context: {\n          name: \"ID_GENERATION_ERROR\",\n          error: e\n        }\n      });\n      closeConnection(Server.errors.BAD_REQUEST);\n      return;\n    }\n\n    debug('handshaking client \"%s\"', id);\n\n    try {\n      var transport = this.createTransport(transportName, req);\n\n      if (\"polling\" === transportName) {\n        transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;\n        transport.httpCompression = this.opts.httpCompression;\n      } else if (\"websocket\" === transportName) {\n        transport.perMessageDeflate = this.opts.perMessageDeflate;\n      }\n\n      if (req._query && req._query.b64) {\n        transport.supportsBinary = false;\n      } else {\n        transport.supportsBinary = true;\n      }\n    } catch (e) {\n      debug('error handshaking to transport \"%s\"', transportName);\n      this.emit(\"connection_error\", {\n        req,\n        code: Server.errors.BAD_REQUEST,\n        message: Server.errorMessages[Server.errors.BAD_REQUEST],\n        context: {\n          name: \"TRANSPORT_HANDSHAKE_ERROR\",\n          error: e\n        }\n      });\n      closeConnection(Server.errors.BAD_REQUEST);\n      return;\n    }\n\n    const socket = new socket_1.Socket(id, this, transport, req, protocol);\n    transport.on(\"headers\", (headers, req) => {\n      const isInitialRequest = !req._query.sid;\n\n      if (isInitialRequest) {\n        if (this.opts.cookie) {\n          headers[\"Set-Cookie\"] = [// @ts-ignore\n          (0, cookie_1.serialize)(this.opts.cookie.name, id, this.opts.cookie)];\n        }\n\n        this.emit(\"initial_headers\", headers, req);\n      }\n\n      this.emit(\"headers\", headers, req);\n    });\n    transport.onRequest(req);\n    this.clients[id] = socket;\n    this.clientsCount++;\n    socket.once(\"close\", () => {\n      delete this.clients[id];\n      this.clientsCount--;\n    });\n    this.emit(\"connection\", socket);\n    return transport;\n  }\n\n}\n\nexports.BaseServer = BaseServer;\n/**\r\n * Protocol errors mappings.\r\n */\n\nBaseServer.errors = {\n  UNKNOWN_TRANSPORT: 0,\n  UNKNOWN_SID: 1,\n  BAD_HANDSHAKE_METHOD: 2,\n  BAD_REQUEST: 3,\n  FORBIDDEN: 4,\n  UNSUPPORTED_PROTOCOL_VERSION: 5\n};\nBaseServer.errorMessages = {\n  0: \"Transport unknown\",\n  1: \"Session ID unknown\",\n  2: \"Bad handshake method\",\n  3: \"Bad request\",\n  4: \"Forbidden\",\n  5: \"Unsupported protocol version\"\n};\n\nclass Server extends BaseServer {\n  /**\r\n   * Initialize websocket server\r\n   *\r\n   * @api protected\r\n   */\n  init() {\n    if (!~this.opts.transports.indexOf(\"websocket\")) return;\n    if (this.ws) this.ws.close();\n    this.ws = new this.opts.wsEngine({\n      noServer: true,\n      clientTracking: false,\n      perMessageDeflate: this.opts.perMessageDeflate,\n      maxPayload: this.opts.maxHttpBufferSize\n    });\n\n    if (typeof this.ws.on === \"function\") {\n      this.ws.on(\"headers\", (headersArray, req) => {\n        // note: 'ws' uses an array of headers, while Engine.IO uses an object (response.writeHead() accepts both formats)\n        // we could also try to parse the array and then sync the values, but that will be error-prone\n        const additionalHeaders = {};\n        const isInitialRequest = !req._query.sid;\n\n        if (isInitialRequest) {\n          this.emit(\"initial_headers\", additionalHeaders, req);\n        }\n\n        this.emit(\"headers\", additionalHeaders, req);\n        Object.keys(additionalHeaders).forEach(key => {\n          headersArray.push(`${key}: ${additionalHeaders[key]}`);\n        });\n      });\n    }\n  }\n\n  cleanup() {\n    if (this.ws) {\n      debug(\"closing webSocketServer\");\n      this.ws.close(); // don't delete this.ws because it can be used again if the http server starts listening again\n    }\n  }\n  /**\r\n   * Prepares a request by processing the query string.\r\n   *\r\n   * @api private\r\n   */\n\n\n  prepare(req) {\n    // try to leverage pre-existing `req._query` (e.g: from connect)\n    if (!req._query) {\n      req._query = ~req.url.indexOf(\"?\") ? qs.parse((0, url_1.parse)(req.url).query) : {};\n    }\n  }\n\n  createTransport(transportName, req) {\n    return new transports_1.default[transportName](req);\n  }\n  /**\r\n   * Handles an Engine.IO HTTP request.\r\n   *\r\n   * @param {http.IncomingMessage} request\r\n   * @param {http.ServerResponse|http.OutgoingMessage} response\r\n   * @api public\r\n   */\n\n\n  handleRequest(req, res) {\n    debug('handling \"%s\" http request \"%s\"', req.method, req.url);\n    this.prepare(req);\n    req.res = res;\n\n    const callback = (errorCode, errorContext) => {\n      if (errorCode !== undefined) {\n        this.emit(\"connection_error\", {\n          req,\n          code: errorCode,\n          message: Server.errorMessages[errorCode],\n          context: errorContext\n        });\n        abortRequest(res, errorCode, errorContext);\n        return;\n      }\n\n      if (req._query.sid) {\n        debug(\"setting new request for existing client\");\n\n        this.clients[req._query.sid].transport.onRequest(req);\n      } else {\n        const closeConnection = (errorCode, errorContext) => abortRequest(res, errorCode, errorContext);\n\n        this.handshake(req._query.transport, req, closeConnection);\n      }\n    };\n\n    if (this.corsMiddleware) {\n      this.corsMiddleware.call(null, req, res, () => {\n        this.verify(req, false, callback);\n      });\n    } else {\n      this.verify(req, false, callback);\n    }\n  }\n  /**\r\n   * Handles an Engine.IO HTTP Upgrade.\r\n   *\r\n   * @api public\r\n   */\n\n\n  handleUpgrade(req, socket, upgradeHead) {\n    this.prepare(req);\n    this.verify(req, true, (errorCode, errorContext) => {\n      if (errorCode) {\n        this.emit(\"connection_error\", {\n          req,\n          code: errorCode,\n          message: Server.errorMessages[errorCode],\n          context: errorContext\n        });\n        abortUpgrade(socket, errorCode, errorContext);\n        return;\n      }\n\n      const head = Buffer.from(upgradeHead); // eslint-disable-line node/no-deprecated-api\n\n      upgradeHead = null; // delegate to ws\n\n      this.ws.handleUpgrade(req, socket, head, websocket => {\n        this.onWebSocket(req, socket, websocket);\n      });\n    });\n  }\n  /**\r\n   * Called upon a ws.io connection.\r\n   *\r\n   * @param {ws.Socket} websocket\r\n   * @api private\r\n   */\n\n\n  onWebSocket(req, socket, websocket) {\n    websocket.on(\"error\", onUpgradeError);\n\n    if (transports_1.default[req._query.transport] !== undefined && !transports_1.default[req._query.transport].prototype.handlesUpgrades) {\n      debug(\"transport doesnt handle upgraded requests\");\n      websocket.close();\n      return;\n    } // get client id\n\n\n    const id = req._query.sid; // keep a reference to the ws.Socket\n\n    req.websocket = websocket;\n\n    if (id) {\n      const client = this.clients[id];\n\n      if (!client) {\n        debug(\"upgrade attempt for closed client\");\n        websocket.close();\n      } else if (client.upgrading) {\n        debug(\"transport has already been trying to upgrade\");\n        websocket.close();\n      } else if (client.upgraded) {\n        debug(\"transport had already been upgraded\");\n        websocket.close();\n      } else {\n        debug(\"upgrading existing transport\"); // transport error handling takes over\n\n        websocket.removeListener(\"error\", onUpgradeError);\n        const transport = this.createTransport(req._query.transport, req);\n\n        if (req._query && req._query.b64) {\n          transport.supportsBinary = false;\n        } else {\n          transport.supportsBinary = true;\n        }\n\n        transport.perMessageDeflate = this.opts.perMessageDeflate;\n        client.maybeUpgrade(transport);\n      }\n    } else {\n      const closeConnection = (errorCode, errorContext) => abortUpgrade(socket, errorCode, errorContext);\n\n      this.handshake(req._query.transport, req, closeConnection);\n    }\n\n    function onUpgradeError() {\n      debug(\"websocket error before upgrade\"); // websocket.close() not needed\n    }\n  }\n  /**\r\n   * Captures upgrade requests for a http.Server.\r\n   *\r\n   * @param {http.Server} server\r\n   * @param {Object} options\r\n   * @api public\r\n   */\n\n\n  attach(server) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let path = (options.path || \"/engine.io\").replace(/\\/$/, \"\");\n    const destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000; // normalize path\n\n    path += \"/\";\n\n    function check(req) {\n      return path === req.url.substr(0, path.length);\n    } // cache and clean up listeners\n\n\n    const listeners = server.listeners(\"request\").slice(0);\n    server.removeAllListeners(\"request\");\n    server.on(\"close\", this.close.bind(this));\n    server.on(\"listening\", this.init.bind(this)); // add request handler\n\n    server.on(\"request\", (req, res) => {\n      if (check(req)) {\n        debug('intercepting request for path \"%s\"', path);\n        this.handleRequest(req, res);\n      } else {\n        let i = 0;\n        const l = listeners.length;\n\n        for (; i < l; i++) {\n          listeners[i].call(server, req, res);\n        }\n      }\n    });\n\n    if (~this.opts.transports.indexOf(\"websocket\")) {\n      server.on(\"upgrade\", (req, socket, head) => {\n        if (check(req)) {\n          this.handleUpgrade(req, socket, head);\n        } else if (false !== options.destroyUpgrade) {\n          // default node behavior is to disconnect when no handlers\n          // but by adding a handler, we prevent that\n          // and if no eio thing handles the upgrade\n          // then the socket needs to die!\n          setTimeout(function () {\n            // @ts-ignore\n            if (socket.writable && socket.bytesWritten <= 0) {\n              return socket.end();\n            }\n          }, destroyUpgradeTimeout);\n        }\n      });\n    }\n  }\n\n}\n\nexports.Server = Server;\n/**\r\n * Close the HTTP long-polling request\r\n *\r\n * @param res - the response object\r\n * @param errorCode - the error code\r\n * @param errorContext - additional error context\r\n *\r\n * @api private\r\n */\n\nfunction abortRequest(res, errorCode, errorContext) {\n  const statusCode = errorCode === Server.errors.FORBIDDEN ? 403 : 400;\n  const message = errorContext && errorContext.message ? errorContext.message : Server.errorMessages[errorCode];\n  res.writeHead(statusCode, {\n    \"Content-Type\": \"application/json\"\n  });\n  res.end(JSON.stringify({\n    code: errorCode,\n    message\n  }));\n}\n/**\r\n * Close the WebSocket connection\r\n *\r\n * @param {net.Socket} socket\r\n * @param {string} errorCode - the error code\r\n * @param {object} errorContext - additional error context\r\n *\r\n * @api private\r\n */\n\n\nfunction abortUpgrade(socket, errorCode) {\n  let errorContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  socket.on(\"error\", () => {\n    debug(\"ignoring error from closed connection\");\n  });\n\n  if (socket.writable) {\n    const message = errorContext.message || Server.errorMessages[errorCode];\n    const length = Buffer.byteLength(message);\n    socket.write(\"HTTP/1.1 400 Bad Request\\r\\n\" + \"Connection: close\\r\\n\" + \"Content-type: text/html\\r\\n\" + \"Content-Length: \" + length + \"\\r\\n\" + \"\\r\\n\" + message);\n  }\n\n  socket.destroy();\n}\n/* eslint-disable */\n\n/**\r\n * From https://github.com/nodejs/node/blob/v8.4.0/lib/_http_common.js#L303-L354\r\n *\r\n * True if val contains an invalid field-vchar\r\n *  field-value    = *( field-content / obs-fold )\r\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\r\n *  field-vchar    = VCHAR / obs-text\r\n *\r\n * checkInvalidHeaderChar() is currently designed to be inlinable by v8,\r\n * so take care when making changes to the implementation so that the source\r\n * code size does not exceed v8's default max_inlined_source_size setting.\r\n **/\n// prettier-ignore\n\n\nconst validHdrChars = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // ... 255\n];\n\nfunction checkInvalidHeaderChar(val) {\n  val += \"\";\n  if (val.length < 1) return false;\n\n  if (!validHdrChars[val.charCodeAt(0)]) {\n    debug('invalid header, index 0, char \"%s\"', val.charCodeAt(0));\n    return true;\n  }\n\n  if (val.length < 2) return false;\n\n  if (!validHdrChars[val.charCodeAt(1)]) {\n    debug('invalid header, index 1, char \"%s\"', val.charCodeAt(1));\n    return true;\n  }\n\n  if (val.length < 3) return false;\n\n  if (!validHdrChars[val.charCodeAt(2)]) {\n    debug('invalid header, index 2, char \"%s\"', val.charCodeAt(2));\n    return true;\n  }\n\n  if (val.length < 4) return false;\n\n  if (!validHdrChars[val.charCodeAt(3)]) {\n    debug('invalid header, index 3, char \"%s\"', val.charCodeAt(3));\n    return true;\n  }\n\n  for (let i = 4; i < val.length; ++i) {\n    if (!validHdrChars[val.charCodeAt(i)]) {\n      debug('invalid header, index \"%i\", char \"%s\"', i, val.charCodeAt(i));\n      return true;\n    }\n  }\n\n  return false;\n}","map":{"version":3,"sources":["C:/Users/gabe/Desktop/Pomo/Team5/client/node_modules/engine.io/build/server.js"],"names":["Object","defineProperty","exports","value","Server","BaseServer","qs","require","url_1","base64id","transports_1","events_1","socket_1","debug_1","cookie_1","ws_1","debug","default","EventEmitter","constructor","opts","clients","clientsCount","assign","wsEngine","pingTimeout","pingInterval","upgradeTimeout","maxHttpBufferSize","transports","keys","allowUpgrades","httpCompression","threshold","cors","allowEIO3","cookie","name","path","httpOnly","sameSite","corsMiddleware","perMessageDeflate","init","upgrades","transport","upgradesTo","verify","req","upgrade","fn","_query","indexOf","errors","UNKNOWN_TRANSPORT","isOriginInvalid","checkInvalidHeaderChar","headers","origin","BAD_REQUEST","sid","hasOwnProperty","UNKNOWN_SID","previousTransport","method","BAD_HANDSHAKE_METHOD","allowRequest","message","success","FORBIDDEN","close","i","cleanup","generateId","handshake","transportName","closeConnection","protocol","EIO","emit","code","UNSUPPORTED_PROTOCOL_VERSION","errorMessages","context","id","e","error","createTransport","b64","supportsBinary","socket","Socket","on","isInitialRequest","serialize","onRequest","once","ws","noServer","clientTracking","maxPayload","headersArray","additionalHeaders","forEach","key","push","prepare","url","parse","query","handleRequest","res","callback","errorCode","errorContext","undefined","abortRequest","call","handleUpgrade","upgradeHead","abortUpgrade","head","Buffer","from","websocket","onWebSocket","onUpgradeError","prototype","handlesUpgrades","client","upgrading","upgraded","removeListener","maybeUpgrade","attach","server","options","replace","destroyUpgradeTimeout","check","substr","length","listeners","slice","removeAllListeners","bind","l","destroyUpgrade","setTimeout","writable","bytesWritten","end","statusCode","writeHead","JSON","stringify","byteLength","write","destroy","validHdrChars","val","charCodeAt"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,MAAR,GAAiBF,OAAO,CAACG,UAAR,GAAqB,KAAK,CAA3C;;AACA,MAAMC,EAAE,GAAGC,OAAO,CAAC,aAAD,CAAlB;;AACA,MAAMC,KAAK,GAAGD,OAAO,CAAC,KAAD,CAArB;;AACA,MAAME,QAAQ,GAAGF,OAAO,CAAC,UAAD,CAAxB;;AACA,MAAMG,YAAY,GAAGH,OAAO,CAAC,cAAD,CAA5B;;AACA,MAAMI,QAAQ,GAAGJ,OAAO,CAAC,QAAD,CAAxB;;AACA,MAAMK,QAAQ,GAAGL,OAAO,CAAC,UAAD,CAAxB;;AACA,MAAMM,OAAO,GAAGN,OAAO,CAAC,OAAD,CAAvB;;AACA,MAAMO,QAAQ,GAAGP,OAAO,CAAC,QAAD,CAAxB;;AACA,MAAMQ,IAAI,GAAGR,OAAO,CAAC,IAAD,CAApB;;AACA,MAAMS,KAAK,GAAG,CAAC,GAAGH,OAAO,CAACI,OAAZ,EAAqB,QAArB,CAAd;;AACA,MAAMZ,UAAN,SAAyBM,QAAQ,CAACO,YAAlC,CAA+C;AAC3C;AACJ;AACA;AACA;AACA;AACA;AACIC,EAAAA,WAAW,GAAY;AAAA,QAAXC,IAAW,uEAAJ,EAAI;AACnB;AACA,SAAKC,OAAL,GAAe,EAAf;AACA,SAAKC,YAAL,GAAoB,CAApB;AACA,SAAKF,IAAL,GAAYpB,MAAM,CAACuB,MAAP,CAAc;AACtBC,MAAAA,QAAQ,EAAET,IAAI,CAACX,MADO;AAEtBqB,MAAAA,WAAW,EAAE,KAFS;AAGtBC,MAAAA,YAAY,EAAE,KAHQ;AAItBC,MAAAA,cAAc,EAAE,KAJM;AAKtBC,MAAAA,iBAAiB,EAAE,GALG;AAMtBC,MAAAA,UAAU,EAAE7B,MAAM,CAAC8B,IAAP,CAAYpB,YAAY,CAACO,OAAzB,CANU;AAOtBc,MAAAA,aAAa,EAAE,IAPO;AAQtBC,MAAAA,eAAe,EAAE;AACbC,QAAAA,SAAS,EAAE;AADE,OARK;AAWtBC,MAAAA,IAAI,EAAE,KAXgB;AAYtBC,MAAAA,SAAS,EAAE;AAZW,KAAd,EAaTf,IAbS,CAAZ;;AAcA,QAAIA,IAAI,CAACgB,MAAT,EAAiB;AACb,WAAKhB,IAAL,CAAUgB,MAAV,GAAmBpC,MAAM,CAACuB,MAAP,CAAc;AAC7Bc,QAAAA,IAAI,EAAE,IADuB;AAE7BC,QAAAA,IAAI,EAAE,GAFuB;AAG7B;AACAC,QAAAA,QAAQ,EAAEnB,IAAI,CAACgB,MAAL,CAAYE,IAAZ,KAAqB,KAJF;AAK7BE,QAAAA,QAAQ,EAAE;AALmB,OAAd,EAMhBpB,IAAI,CAACgB,MANW,CAAnB;AAOH;;AACD,QAAI,KAAKhB,IAAL,CAAUc,IAAd,EAAoB;AAChB,WAAKO,cAAL,GAAsBlC,OAAO,CAAC,MAAD,CAAP,CAAgB,KAAKa,IAAL,CAAUc,IAA1B,CAAtB;AACH;;AACD,QAAId,IAAI,CAACsB,iBAAT,EAA4B;AACxB,WAAKtB,IAAL,CAAUsB,iBAAV,GAA8B1C,MAAM,CAACuB,MAAP,CAAc;AACxCU,QAAAA,SAAS,EAAE;AAD6B,OAAd,EAE3Bb,IAAI,CAACsB,iBAFsB,CAA9B;AAGH;;AACD,SAAKC,IAAL;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,QAAQ,CAACC,SAAD,EAAY;AAChB,QAAI,CAAC,KAAKzB,IAAL,CAAUW,aAAf,EACI,OAAO,EAAP;AACJ,WAAOrB,YAAY,CAACO,OAAb,CAAqB4B,SAArB,EAAgCC,UAAhC,IAA8C,EAArD;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,MAAM,CAACC,GAAD,EAAMC,OAAN,EAAeC,EAAf,EAAmB;AACrB;AACA,UAAML,SAAS,GAAGG,GAAG,CAACG,MAAJ,CAAWN,SAA7B;;AACA,QAAI,CAAC,CAAC,KAAKzB,IAAL,CAAUS,UAAV,CAAqBuB,OAArB,CAA6BP,SAA7B,CAAN,EAA+C;AAC3C7B,MAAAA,KAAK,CAAC,wBAAD,EAA2B6B,SAA3B,CAAL;AACA,aAAOK,EAAE,CAAC9C,MAAM,CAACiD,MAAP,CAAcC,iBAAf,EAAkC;AAAET,QAAAA;AAAF,OAAlC,CAAT;AACH,KANoB,CAOrB;;;AACA,UAAMU,eAAe,GAAGC,sBAAsB,CAACR,GAAG,CAACS,OAAJ,CAAYC,MAAb,CAA9C;;AACA,QAAIH,eAAJ,EAAqB;AACjB,YAAMG,MAAM,GAAGV,GAAG,CAACS,OAAJ,CAAYC,MAA3B;AACAV,MAAAA,GAAG,CAACS,OAAJ,CAAYC,MAAZ,GAAqB,IAArB;AACA1C,MAAAA,KAAK,CAAC,uBAAD,CAAL;AACA,aAAOkC,EAAE,CAAC9C,MAAM,CAACiD,MAAP,CAAcM,WAAf,EAA4B;AACjCtB,QAAAA,IAAI,EAAE,gBAD2B;AAEjCqB,QAAAA;AAFiC,OAA5B,CAAT;AAIH,KAjBoB,CAkBrB;;;AACA,UAAME,GAAG,GAAGZ,GAAG,CAACG,MAAJ,CAAWS,GAAvB;;AACA,QAAIA,GAAJ,EAAS;AACL,UAAI,CAAC,KAAKvC,OAAL,CAAawC,cAAb,CAA4BD,GAA5B,CAAL,EAAuC;AACnC5C,QAAAA,KAAK,CAAC,kBAAD,EAAqB4C,GAArB,CAAL;AACA,eAAOV,EAAE,CAAC9C,MAAM,CAACiD,MAAP,CAAcS,WAAf,EAA4B;AACjCF,UAAAA;AADiC,SAA5B,CAAT;AAGH;;AACD,YAAMG,iBAAiB,GAAG,KAAK1C,OAAL,CAAauC,GAAb,EAAkBf,SAAlB,CAA4BR,IAAtD;;AACA,UAAI,CAACY,OAAD,IAAYc,iBAAiB,KAAKlB,SAAtC,EAAiD;AAC7C7B,QAAAA,KAAK,CAAC,mDAAD,CAAL;AACA,eAAOkC,EAAE,CAAC9C,MAAM,CAACiD,MAAP,CAAcM,WAAf,EAA4B;AACjCtB,UAAAA,IAAI,EAAE,oBAD2B;AAEjCQ,UAAAA,SAFiC;AAGjCkB,UAAAA;AAHiC,SAA5B,CAAT;AAKH;AACJ,KAhBD,MAiBK;AACD;AACA,UAAI,UAAUf,GAAG,CAACgB,MAAlB,EAA0B;AACtB,eAAOd,EAAE,CAAC9C,MAAM,CAACiD,MAAP,CAAcY,oBAAf,EAAqC;AAC1CD,UAAAA,MAAM,EAAEhB,GAAG,CAACgB;AAD8B,SAArC,CAAT;AAGH;;AACD,UAAInB,SAAS,KAAK,WAAd,IAA6B,CAACI,OAAlC,EAA2C;AACvCjC,QAAAA,KAAK,CAAC,2BAAD,CAAL;AACA,eAAOkC,EAAE,CAAC9C,MAAM,CAACiD,MAAP,CAAcM,WAAf,EAA4B;AACjCtB,UAAAA,IAAI,EAAE;AAD2B,SAA5B,CAAT;AAGH;;AACD,UAAI,CAAC,KAAKjB,IAAL,CAAU8C,YAAf,EACI,OAAOhB,EAAE,EAAT;AACJ,aAAO,KAAK9B,IAAL,CAAU8C,YAAV,CAAuBlB,GAAvB,EAA4B,CAACmB,OAAD,EAAUC,OAAV,KAAsB;AACrD,YAAI,CAACA,OAAL,EAAc;AACV,iBAAOlB,EAAE,CAAC9C,MAAM,CAACiD,MAAP,CAAcgB,SAAf,EAA0B;AAC/BF,YAAAA;AAD+B,WAA1B,CAAT;AAGH;;AACDjB,QAAAA,EAAE;AACL,OAPM,CAAP;AAQH;;AACDA,IAAAA,EAAE;AACL;AACD;AACJ;AACA;AACA;AACA;;;AACIoB,EAAAA,KAAK,GAAG;AACJtD,IAAAA,KAAK,CAAC,0BAAD,CAAL;;AACA,SAAK,IAAIuD,CAAT,IAAc,KAAKlD,OAAnB,EAA4B;AACxB,UAAI,KAAKA,OAAL,CAAawC,cAAb,CAA4BU,CAA5B,CAAJ,EAAoC;AAChC,aAAKlD,OAAL,CAAakD,CAAb,EAAgBD,KAAhB,CAAsB,IAAtB;AACH;AACJ;;AACD,SAAKE,OAAL;AACA,WAAO,IAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,UAAU,CAACzB,GAAD,EAAM;AACZ,WAAOvC,QAAQ,CAACgE,UAAT,EAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACmB,QAATC,SAAS,CAACC,aAAD,EAAgB3B,GAAhB,EAAqB4B,eAArB,EAAsC;AACjD,UAAMC,QAAQ,GAAG7B,GAAG,CAACG,MAAJ,CAAW2B,GAAX,KAAmB,GAAnB,GAAyB,CAAzB,GAA6B,CAA9C,CADiD,CACA;;AACjD,QAAID,QAAQ,KAAK,CAAb,IAAkB,CAAC,KAAKzD,IAAL,CAAUe,SAAjC,EAA4C;AACxCnB,MAAAA,KAAK,CAAC,8BAAD,CAAL;AACA,WAAK+D,IAAL,CAAU,kBAAV,EAA8B;AAC1B/B,QAAAA,GAD0B;AAE1BgC,QAAAA,IAAI,EAAE5E,MAAM,CAACiD,MAAP,CAAc4B,4BAFM;AAG1Bd,QAAAA,OAAO,EAAE/D,MAAM,CAAC8E,aAAP,CAAqB9E,MAAM,CAACiD,MAAP,CAAc4B,4BAAnC,CAHiB;AAI1BE,QAAAA,OAAO,EAAE;AACLN,UAAAA;AADK;AAJiB,OAA9B;AAQAD,MAAAA,eAAe,CAACxE,MAAM,CAACiD,MAAP,CAAc4B,4BAAf,CAAf;AACA;AACH;;AACD,QAAIG,EAAJ;;AACA,QAAI;AACAA,MAAAA,EAAE,GAAG,MAAM,KAAKX,UAAL,CAAgBzB,GAAhB,CAAX;AACH,KAFD,CAGA,OAAOqC,CAAP,EAAU;AACNrE,MAAAA,KAAK,CAAC,8BAAD,CAAL;AACA,WAAK+D,IAAL,CAAU,kBAAV,EAA8B;AAC1B/B,QAAAA,GAD0B;AAE1BgC,QAAAA,IAAI,EAAE5E,MAAM,CAACiD,MAAP,CAAcM,WAFM;AAG1BQ,QAAAA,OAAO,EAAE/D,MAAM,CAAC8E,aAAP,CAAqB9E,MAAM,CAACiD,MAAP,CAAcM,WAAnC,CAHiB;AAI1BwB,QAAAA,OAAO,EAAE;AACL9C,UAAAA,IAAI,EAAE,qBADD;AAELiD,UAAAA,KAAK,EAAED;AAFF;AAJiB,OAA9B;AASAT,MAAAA,eAAe,CAACxE,MAAM,CAACiD,MAAP,CAAcM,WAAf,CAAf;AACA;AACH;;AACD3C,IAAAA,KAAK,CAAC,yBAAD,EAA4BoE,EAA5B,CAAL;;AACA,QAAI;AACA,UAAIvC,SAAS,GAAG,KAAK0C,eAAL,CAAqBZ,aAArB,EAAoC3B,GAApC,CAAhB;;AACA,UAAI,cAAc2B,aAAlB,EAAiC;AAC7B9B,QAAAA,SAAS,CAACjB,iBAAV,GAA8B,KAAKR,IAAL,CAAUQ,iBAAxC;AACAiB,QAAAA,SAAS,CAACb,eAAV,GAA4B,KAAKZ,IAAL,CAAUY,eAAtC;AACH,OAHD,MAIK,IAAI,gBAAgB2C,aAApB,EAAmC;AACpC9B,QAAAA,SAAS,CAACH,iBAAV,GAA8B,KAAKtB,IAAL,CAAUsB,iBAAxC;AACH;;AACD,UAAIM,GAAG,CAACG,MAAJ,IAAcH,GAAG,CAACG,MAAJ,CAAWqC,GAA7B,EAAkC;AAC9B3C,QAAAA,SAAS,CAAC4C,cAAV,GAA2B,KAA3B;AACH,OAFD,MAGK;AACD5C,QAAAA,SAAS,CAAC4C,cAAV,GAA2B,IAA3B;AACH;AACJ,KAfD,CAgBA,OAAOJ,CAAP,EAAU;AACNrE,MAAAA,KAAK,CAAC,qCAAD,EAAwC2D,aAAxC,CAAL;AACA,WAAKI,IAAL,CAAU,kBAAV,EAA8B;AAC1B/B,QAAAA,GAD0B;AAE1BgC,QAAAA,IAAI,EAAE5E,MAAM,CAACiD,MAAP,CAAcM,WAFM;AAG1BQ,QAAAA,OAAO,EAAE/D,MAAM,CAAC8E,aAAP,CAAqB9E,MAAM,CAACiD,MAAP,CAAcM,WAAnC,CAHiB;AAI1BwB,QAAAA,OAAO,EAAE;AACL9C,UAAAA,IAAI,EAAE,2BADD;AAELiD,UAAAA,KAAK,EAAED;AAFF;AAJiB,OAA9B;AASAT,MAAAA,eAAe,CAACxE,MAAM,CAACiD,MAAP,CAAcM,WAAf,CAAf;AACA;AACH;;AACD,UAAM+B,MAAM,GAAG,IAAI9E,QAAQ,CAAC+E,MAAb,CAAoBP,EAApB,EAAwB,IAAxB,EAA8BvC,SAA9B,EAAyCG,GAAzC,EAA8C6B,QAA9C,CAAf;AACAhC,IAAAA,SAAS,CAAC+C,EAAV,CAAa,SAAb,EAAwB,CAACnC,OAAD,EAAUT,GAAV,KAAkB;AACtC,YAAM6C,gBAAgB,GAAG,CAAC7C,GAAG,CAACG,MAAJ,CAAWS,GAArC;;AACA,UAAIiC,gBAAJ,EAAsB;AAClB,YAAI,KAAKzE,IAAL,CAAUgB,MAAd,EAAsB;AAClBqB,UAAAA,OAAO,CAAC,YAAD,CAAP,GAAwB,CACpB;AACA,WAAC,GAAG3C,QAAQ,CAACgF,SAAb,EAAwB,KAAK1E,IAAL,CAAUgB,MAAV,CAAiBC,IAAzC,EAA+C+C,EAA/C,EAAmD,KAAKhE,IAAL,CAAUgB,MAA7D,CAFoB,CAAxB;AAIH;;AACD,aAAK2C,IAAL,CAAU,iBAAV,EAA6BtB,OAA7B,EAAsCT,GAAtC;AACH;;AACD,WAAK+B,IAAL,CAAU,SAAV,EAAqBtB,OAArB,EAA8BT,GAA9B;AACH,KAZD;AAaAH,IAAAA,SAAS,CAACkD,SAAV,CAAoB/C,GAApB;AACA,SAAK3B,OAAL,CAAa+D,EAAb,IAAmBM,MAAnB;AACA,SAAKpE,YAAL;AACAoE,IAAAA,MAAM,CAACM,IAAP,CAAY,OAAZ,EAAqB,MAAM;AACvB,aAAO,KAAK3E,OAAL,CAAa+D,EAAb,CAAP;AACA,WAAK9D,YAAL;AACH,KAHD;AAIA,SAAKyD,IAAL,CAAU,YAAV,EAAwBW,MAAxB;AACA,WAAO7C,SAAP;AACH;;AAtP0C;;AAwP/C3C,OAAO,CAACG,UAAR,GAAqBA,UAArB;AACA;AACA;AACA;;AACAA,UAAU,CAACgD,MAAX,GAAoB;AAChBC,EAAAA,iBAAiB,EAAE,CADH;AAEhBQ,EAAAA,WAAW,EAAE,CAFG;AAGhBG,EAAAA,oBAAoB,EAAE,CAHN;AAIhBN,EAAAA,WAAW,EAAE,CAJG;AAKhBU,EAAAA,SAAS,EAAE,CALK;AAMhBY,EAAAA,4BAA4B,EAAE;AANd,CAApB;AAQA5E,UAAU,CAAC6E,aAAX,GAA2B;AACvB,KAAG,mBADoB;AAEvB,KAAG,oBAFoB;AAGvB,KAAG,sBAHoB;AAIvB,KAAG,aAJoB;AAKvB,KAAG,WALoB;AAMvB,KAAG;AANoB,CAA3B;;AAQA,MAAM9E,MAAN,SAAqBC,UAArB,CAAgC;AAC5B;AACJ;AACA;AACA;AACA;AACIsC,EAAAA,IAAI,GAAG;AACH,QAAI,CAAC,CAAC,KAAKvB,IAAL,CAAUS,UAAV,CAAqBuB,OAArB,CAA6B,WAA7B,CAAN,EACI;AACJ,QAAI,KAAK6C,EAAT,EACI,KAAKA,EAAL,CAAQ3B,KAAR;AACJ,SAAK2B,EAAL,GAAU,IAAI,KAAK7E,IAAL,CAAUI,QAAd,CAAuB;AAC7B0E,MAAAA,QAAQ,EAAE,IADmB;AAE7BC,MAAAA,cAAc,EAAE,KAFa;AAG7BzD,MAAAA,iBAAiB,EAAE,KAAKtB,IAAL,CAAUsB,iBAHA;AAI7B0D,MAAAA,UAAU,EAAE,KAAKhF,IAAL,CAAUQ;AAJO,KAAvB,CAAV;;AAMA,QAAI,OAAO,KAAKqE,EAAL,CAAQL,EAAf,KAAsB,UAA1B,EAAsC;AAClC,WAAKK,EAAL,CAAQL,EAAR,CAAW,SAAX,EAAsB,CAACS,YAAD,EAAerD,GAAf,KAAuB;AACzC;AACA;AACA,cAAMsD,iBAAiB,GAAG,EAA1B;AACA,cAAMT,gBAAgB,GAAG,CAAC7C,GAAG,CAACG,MAAJ,CAAWS,GAArC;;AACA,YAAIiC,gBAAJ,EAAsB;AAClB,eAAKd,IAAL,CAAU,iBAAV,EAA6BuB,iBAA7B,EAAgDtD,GAAhD;AACH;;AACD,aAAK+B,IAAL,CAAU,SAAV,EAAqBuB,iBAArB,EAAwCtD,GAAxC;AACAhD,QAAAA,MAAM,CAAC8B,IAAP,CAAYwE,iBAAZ,EAA+BC,OAA/B,CAAuCC,GAAG,IAAI;AAC1CH,UAAAA,YAAY,CAACI,IAAb,CAAmB,GAAED,GAAI,KAAIF,iBAAiB,CAACE,GAAD,CAAM,EAApD;AACH,SAFD;AAGH,OAZD;AAaH;AACJ;;AACDhC,EAAAA,OAAO,GAAG;AACN,QAAI,KAAKyB,EAAT,EAAa;AACTjF,MAAAA,KAAK,CAAC,yBAAD,CAAL;AACA,WAAKiF,EAAL,CAAQ3B,KAAR,GAFS,CAGT;AACH;AACJ;AACD;AACJ;AACA;AACA;AACA;;;AACIoC,EAAAA,OAAO,CAAC1D,GAAD,EAAM;AACT;AACA,QAAI,CAACA,GAAG,CAACG,MAAT,EAAiB;AACbH,MAAAA,GAAG,CAACG,MAAJ,GAAa,CAACH,GAAG,CAAC2D,GAAJ,CAAQvD,OAAR,CAAgB,GAAhB,CAAD,GAAwB9C,EAAE,CAACsG,KAAH,CAAS,CAAC,GAAGpG,KAAK,CAACoG,KAAV,EAAiB5D,GAAG,CAAC2D,GAArB,EAA0BE,KAAnC,CAAxB,GAAoE,EAAjF;AACH;AACJ;;AACDtB,EAAAA,eAAe,CAACZ,aAAD,EAAgB3B,GAAhB,EAAqB;AAChC,WAAO,IAAItC,YAAY,CAACO,OAAb,CAAqB0D,aAArB,CAAJ,CAAwC3B,GAAxC,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACI8D,EAAAA,aAAa,CAAC9D,GAAD,EAAM+D,GAAN,EAAW;AACpB/F,IAAAA,KAAK,CAAC,iCAAD,EAAoCgC,GAAG,CAACgB,MAAxC,EAAgDhB,GAAG,CAAC2D,GAApD,CAAL;AACA,SAAKD,OAAL,CAAa1D,GAAb;AACAA,IAAAA,GAAG,CAAC+D,GAAJ,GAAUA,GAAV;;AACA,UAAMC,QAAQ,GAAG,CAACC,SAAD,EAAYC,YAAZ,KAA6B;AAC1C,UAAID,SAAS,KAAKE,SAAlB,EAA6B;AACzB,aAAKpC,IAAL,CAAU,kBAAV,EAA8B;AAC1B/B,UAAAA,GAD0B;AAE1BgC,UAAAA,IAAI,EAAEiC,SAFoB;AAG1B9C,UAAAA,OAAO,EAAE/D,MAAM,CAAC8E,aAAP,CAAqB+B,SAArB,CAHiB;AAI1B9B,UAAAA,OAAO,EAAE+B;AAJiB,SAA9B;AAMAE,QAAAA,YAAY,CAACL,GAAD,EAAME,SAAN,EAAiBC,YAAjB,CAAZ;AACA;AACH;;AACD,UAAIlE,GAAG,CAACG,MAAJ,CAAWS,GAAf,EAAoB;AAChB5C,QAAAA,KAAK,CAAC,yCAAD,CAAL;;AACA,aAAKK,OAAL,CAAa2B,GAAG,CAACG,MAAJ,CAAWS,GAAxB,EAA6Bf,SAA7B,CAAuCkD,SAAvC,CAAiD/C,GAAjD;AACH,OAHD,MAIK;AACD,cAAM4B,eAAe,GAAG,CAACqC,SAAD,EAAYC,YAAZ,KAA6BE,YAAY,CAACL,GAAD,EAAME,SAAN,EAAiBC,YAAjB,CAAjE;;AACA,aAAKxC,SAAL,CAAe1B,GAAG,CAACG,MAAJ,CAAWN,SAA1B,EAAqCG,GAArC,EAA0C4B,eAA1C;AACH;AACJ,KAnBD;;AAoBA,QAAI,KAAKnC,cAAT,EAAyB;AACrB,WAAKA,cAAL,CAAoB4E,IAApB,CAAyB,IAAzB,EAA+BrE,GAA/B,EAAoC+D,GAApC,EAAyC,MAAM;AAC3C,aAAKhE,MAAL,CAAYC,GAAZ,EAAiB,KAAjB,EAAwBgE,QAAxB;AACH,OAFD;AAGH,KAJD,MAKK;AACD,WAAKjE,MAAL,CAAYC,GAAZ,EAAiB,KAAjB,EAAwBgE,QAAxB;AACH;AACJ;AACD;AACJ;AACA;AACA;AACA;;;AACIM,EAAAA,aAAa,CAACtE,GAAD,EAAM0C,MAAN,EAAc6B,WAAd,EAA2B;AACpC,SAAKb,OAAL,CAAa1D,GAAb;AACA,SAAKD,MAAL,CAAYC,GAAZ,EAAiB,IAAjB,EAAuB,CAACiE,SAAD,EAAYC,YAAZ,KAA6B;AAChD,UAAID,SAAJ,EAAe;AACX,aAAKlC,IAAL,CAAU,kBAAV,EAA8B;AAC1B/B,UAAAA,GAD0B;AAE1BgC,UAAAA,IAAI,EAAEiC,SAFoB;AAG1B9C,UAAAA,OAAO,EAAE/D,MAAM,CAAC8E,aAAP,CAAqB+B,SAArB,CAHiB;AAI1B9B,UAAAA,OAAO,EAAE+B;AAJiB,SAA9B;AAMAM,QAAAA,YAAY,CAAC9B,MAAD,EAASuB,SAAT,EAAoBC,YAApB,CAAZ;AACA;AACH;;AACD,YAAMO,IAAI,GAAGC,MAAM,CAACC,IAAP,CAAYJ,WAAZ,CAAb,CAXgD,CAWT;;AACvCA,MAAAA,WAAW,GAAG,IAAd,CAZgD,CAahD;;AACA,WAAKtB,EAAL,CAAQqB,aAAR,CAAsBtE,GAAtB,EAA2B0C,MAA3B,EAAmC+B,IAAnC,EAAyCG,SAAS,IAAI;AAClD,aAAKC,WAAL,CAAiB7E,GAAjB,EAAsB0C,MAAtB,EAA8BkC,SAA9B;AACH,OAFD;AAGH,KAjBD;AAkBH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,WAAW,CAAC7E,GAAD,EAAM0C,MAAN,EAAckC,SAAd,EAAyB;AAChCA,IAAAA,SAAS,CAAChC,EAAV,CAAa,OAAb,EAAsBkC,cAAtB;;AACA,QAAIpH,YAAY,CAACO,OAAb,CAAqB+B,GAAG,CAACG,MAAJ,CAAWN,SAAhC,MAA+CsE,SAA/C,IACA,CAACzG,YAAY,CAACO,OAAb,CAAqB+B,GAAG,CAACG,MAAJ,CAAWN,SAAhC,EAA2CkF,SAA3C,CAAqDC,eAD1D,EAC2E;AACvEhH,MAAAA,KAAK,CAAC,2CAAD,CAAL;AACA4G,MAAAA,SAAS,CAACtD,KAAV;AACA;AACH,KAP+B,CAQhC;;;AACA,UAAMc,EAAE,GAAGpC,GAAG,CAACG,MAAJ,CAAWS,GAAtB,CATgC,CAUhC;;AACAZ,IAAAA,GAAG,CAAC4E,SAAJ,GAAgBA,SAAhB;;AACA,QAAIxC,EAAJ,EAAQ;AACJ,YAAM6C,MAAM,GAAG,KAAK5G,OAAL,CAAa+D,EAAb,CAAf;;AACA,UAAI,CAAC6C,MAAL,EAAa;AACTjH,QAAAA,KAAK,CAAC,mCAAD,CAAL;AACA4G,QAAAA,SAAS,CAACtD,KAAV;AACH,OAHD,MAIK,IAAI2D,MAAM,CAACC,SAAX,EAAsB;AACvBlH,QAAAA,KAAK,CAAC,8CAAD,CAAL;AACA4G,QAAAA,SAAS,CAACtD,KAAV;AACH,OAHI,MAIA,IAAI2D,MAAM,CAACE,QAAX,EAAqB;AACtBnH,QAAAA,KAAK,CAAC,qCAAD,CAAL;AACA4G,QAAAA,SAAS,CAACtD,KAAV;AACH,OAHI,MAIA;AACDtD,QAAAA,KAAK,CAAC,8BAAD,CAAL,CADC,CAED;;AACA4G,QAAAA,SAAS,CAACQ,cAAV,CAAyB,OAAzB,EAAkCN,cAAlC;AACA,cAAMjF,SAAS,GAAG,KAAK0C,eAAL,CAAqBvC,GAAG,CAACG,MAAJ,CAAWN,SAAhC,EAA2CG,GAA3C,CAAlB;;AACA,YAAIA,GAAG,CAACG,MAAJ,IAAcH,GAAG,CAACG,MAAJ,CAAWqC,GAA7B,EAAkC;AAC9B3C,UAAAA,SAAS,CAAC4C,cAAV,GAA2B,KAA3B;AACH,SAFD,MAGK;AACD5C,UAAAA,SAAS,CAAC4C,cAAV,GAA2B,IAA3B;AACH;;AACD5C,QAAAA,SAAS,CAACH,iBAAV,GAA8B,KAAKtB,IAAL,CAAUsB,iBAAxC;AACAuF,QAAAA,MAAM,CAACI,YAAP,CAAoBxF,SAApB;AACH;AACJ,KA5BD,MA6BK;AACD,YAAM+B,eAAe,GAAG,CAACqC,SAAD,EAAYC,YAAZ,KAA6BM,YAAY,CAAC9B,MAAD,EAASuB,SAAT,EAAoBC,YAApB,CAAjE;;AACA,WAAKxC,SAAL,CAAe1B,GAAG,CAACG,MAAJ,CAAWN,SAA1B,EAAqCG,GAArC,EAA0C4B,eAA1C;AACH;;AACD,aAASkD,cAAT,GAA0B;AACtB9G,MAAAA,KAAK,CAAC,gCAAD,CAAL,CADsB,CAEtB;AACH;AACJ;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIsH,EAAAA,MAAM,CAACC,MAAD,EAAuB;AAAA,QAAdC,OAAc,uEAAJ,EAAI;AACzB,QAAIlG,IAAI,GAAG,CAACkG,OAAO,CAAClG,IAAR,IAAgB,YAAjB,EAA+BmG,OAA/B,CAAuC,KAAvC,EAA8C,EAA9C,CAAX;AACA,UAAMC,qBAAqB,GAAGF,OAAO,CAACE,qBAAR,IAAiC,IAA/D,CAFyB,CAGzB;;AACApG,IAAAA,IAAI,IAAI,GAAR;;AACA,aAASqG,KAAT,CAAe3F,GAAf,EAAoB;AAChB,aAAOV,IAAI,KAAKU,GAAG,CAAC2D,GAAJ,CAAQiC,MAAR,CAAe,CAAf,EAAkBtG,IAAI,CAACuG,MAAvB,CAAhB;AACH,KAPwB,CAQzB;;;AACA,UAAMC,SAAS,GAAGP,MAAM,CAACO,SAAP,CAAiB,SAAjB,EAA4BC,KAA5B,CAAkC,CAAlC,CAAlB;AACAR,IAAAA,MAAM,CAACS,kBAAP,CAA0B,SAA1B;AACAT,IAAAA,MAAM,CAAC3C,EAAP,CAAU,OAAV,EAAmB,KAAKtB,KAAL,CAAW2E,IAAX,CAAgB,IAAhB,CAAnB;AACAV,IAAAA,MAAM,CAAC3C,EAAP,CAAU,WAAV,EAAuB,KAAKjD,IAAL,CAAUsG,IAAV,CAAe,IAAf,CAAvB,EAZyB,CAazB;;AACAV,IAAAA,MAAM,CAAC3C,EAAP,CAAU,SAAV,EAAqB,CAAC5C,GAAD,EAAM+D,GAAN,KAAc;AAC/B,UAAI4B,KAAK,CAAC3F,GAAD,CAAT,EAAgB;AACZhC,QAAAA,KAAK,CAAC,oCAAD,EAAuCsB,IAAvC,CAAL;AACA,aAAKwE,aAAL,CAAmB9D,GAAnB,EAAwB+D,GAAxB;AACH,OAHD,MAIK;AACD,YAAIxC,CAAC,GAAG,CAAR;AACA,cAAM2E,CAAC,GAAGJ,SAAS,CAACD,MAApB;;AACA,eAAOtE,CAAC,GAAG2E,CAAX,EAAc3E,CAAC,EAAf,EAAmB;AACfuE,UAAAA,SAAS,CAACvE,CAAD,CAAT,CAAa8C,IAAb,CAAkBkB,MAAlB,EAA0BvF,GAA1B,EAA+B+D,GAA/B;AACH;AACJ;AACJ,KAZD;;AAaA,QAAI,CAAC,KAAK3F,IAAL,CAAUS,UAAV,CAAqBuB,OAArB,CAA6B,WAA7B,CAAL,EAAgD;AAC5CmF,MAAAA,MAAM,CAAC3C,EAAP,CAAU,SAAV,EAAqB,CAAC5C,GAAD,EAAM0C,MAAN,EAAc+B,IAAd,KAAuB;AACxC,YAAIkB,KAAK,CAAC3F,GAAD,CAAT,EAAgB;AACZ,eAAKsE,aAAL,CAAmBtE,GAAnB,EAAwB0C,MAAxB,EAAgC+B,IAAhC;AACH,SAFD,MAGK,IAAI,UAAUe,OAAO,CAACW,cAAtB,EAAsC;AACvC;AACA;AACA;AACA;AACAC,UAAAA,UAAU,CAAC,YAAY;AACnB;AACA,gBAAI1D,MAAM,CAAC2D,QAAP,IAAmB3D,MAAM,CAAC4D,YAAP,IAAuB,CAA9C,EAAiD;AAC7C,qBAAO5D,MAAM,CAAC6D,GAAP,EAAP;AACH;AACJ,WALS,EAKPb,qBALO,CAAV;AAMH;AACJ,OAhBD;AAiBH;AACJ;;AArO2B;;AAuOhCxI,OAAO,CAACE,MAAR,GAAiBA,MAAjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASgH,YAAT,CAAsBL,GAAtB,EAA2BE,SAA3B,EAAsCC,YAAtC,EAAoD;AAChD,QAAMsC,UAAU,GAAGvC,SAAS,KAAK7G,MAAM,CAACiD,MAAP,CAAcgB,SAA5B,GAAwC,GAAxC,GAA8C,GAAjE;AACA,QAAMF,OAAO,GAAG+C,YAAY,IAAIA,YAAY,CAAC/C,OAA7B,GACV+C,YAAY,CAAC/C,OADH,GAEV/D,MAAM,CAAC8E,aAAP,CAAqB+B,SAArB,CAFN;AAGAF,EAAAA,GAAG,CAAC0C,SAAJ,CAAcD,UAAd,EAA0B;AAAE,oBAAgB;AAAlB,GAA1B;AACAzC,EAAAA,GAAG,CAACwC,GAAJ,CAAQG,IAAI,CAACC,SAAL,CAAe;AACnB3E,IAAAA,IAAI,EAAEiC,SADa;AAEnB9C,IAAAA;AAFmB,GAAf,CAAR;AAIH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASqD,YAAT,CAAsB9B,MAAtB,EAA8BuB,SAA9B,EAA4D;AAAA,MAAnBC,YAAmB,uEAAJ,EAAI;AACxDxB,EAAAA,MAAM,CAACE,EAAP,CAAU,OAAV,EAAmB,MAAM;AACrB5E,IAAAA,KAAK,CAAC,uCAAD,CAAL;AACH,GAFD;;AAGA,MAAI0E,MAAM,CAAC2D,QAAX,EAAqB;AACjB,UAAMlF,OAAO,GAAG+C,YAAY,CAAC/C,OAAb,IAAwB/D,MAAM,CAAC8E,aAAP,CAAqB+B,SAArB,CAAxC;AACA,UAAM4B,MAAM,GAAGnB,MAAM,CAACkC,UAAP,CAAkBzF,OAAlB,CAAf;AACAuB,IAAAA,MAAM,CAACmE,KAAP,CAAa,iCACT,uBADS,GAET,6BAFS,GAGT,kBAHS,GAIThB,MAJS,GAKT,MALS,GAMT,MANS,GAOT1E,OAPJ;AAQH;;AACDuB,EAAAA,MAAM,CAACoE,OAAP;AACH;AACD;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,aAAa,GAAG,CAClB,CADkB,EACf,CADe,EACZ,CADY,EACT,CADS,EACN,CADM,EACH,CADG,EACA,CADA,EACG,CADH,EACM,CADN,EACS,CADT,EACY,CADZ,EACe,CADf,EACkB,CADlB,EACqB,CADrB,EACwB,CADxB,EAC2B,CAD3B,EAElB,CAFkB,EAEf,CAFe,EAEZ,CAFY,EAET,CAFS,EAEN,CAFM,EAEH,CAFG,EAEA,CAFA,EAEG,CAFH,EAEM,CAFN,EAES,CAFT,EAEY,CAFZ,EAEe,CAFf,EAEkB,CAFlB,EAEqB,CAFrB,EAEwB,CAFxB,EAE2B,CAF3B,EAGlB,CAHkB,EAGf,CAHe,EAGZ,CAHY,EAGT,CAHS,EAGN,CAHM,EAGH,CAHG,EAGA,CAHA,EAGG,CAHH,EAGM,CAHN,EAGS,CAHT,EAGY,CAHZ,EAGe,CAHf,EAGkB,CAHlB,EAGqB,CAHrB,EAGwB,CAHxB,EAG2B,CAH3B,EAIlB,CAJkB,EAIf,CAJe,EAIZ,CAJY,EAIT,CAJS,EAIN,CAJM,EAIH,CAJG,EAIA,CAJA,EAIG,CAJH,EAIM,CAJN,EAIS,CAJT,EAIY,CAJZ,EAIe,CAJf,EAIkB,CAJlB,EAIqB,CAJrB,EAIwB,CAJxB,EAI2B,CAJ3B,EAKlB,CALkB,EAKf,CALe,EAKZ,CALY,EAKT,CALS,EAKN,CALM,EAKH,CALG,EAKA,CALA,EAKG,CALH,EAKM,CALN,EAKS,CALT,EAKY,CALZ,EAKe,CALf,EAKkB,CALlB,EAKqB,CALrB,EAKwB,CALxB,EAK2B,CAL3B,EAMlB,CANkB,EAMf,CANe,EAMZ,CANY,EAMT,CANS,EAMN,CANM,EAMH,CANG,EAMA,CANA,EAMG,CANH,EAMM,CANN,EAMS,CANT,EAMY,CANZ,EAMe,CANf,EAMkB,CANlB,EAMqB,CANrB,EAMwB,CANxB,EAM2B,CAN3B,EAOlB,CAPkB,EAOf,CAPe,EAOZ,CAPY,EAOT,CAPS,EAON,CAPM,EAOH,CAPG,EAOA,CAPA,EAOG,CAPH,EAOM,CAPN,EAOS,CAPT,EAOY,CAPZ,EAOe,CAPf,EAOkB,CAPlB,EAOqB,CAPrB,EAOwB,CAPxB,EAO2B,CAP3B,EAQlB,CARkB,EAQf,CARe,EAQZ,CARY,EAQT,CARS,EAQN,CARM,EAQH,CARG,EAQA,CARA,EAQG,CARH,EAQM,CARN,EAQS,CART,EAQY,CARZ,EAQe,CARf,EAQkB,CARlB,EAQqB,CARrB,EAQwB,CARxB,EAQ2B,CAR3B,EASlB,CATkB,EASf,CATe,EASZ,CATY,EAST,CATS,EASN,CATM,EASH,CATG,EASA,CATA,EASG,CATH,EASM,CATN,EASS,CATT,EASY,CATZ,EASe,CATf,EASkB,CATlB,EASqB,CATrB,EASwB,CATxB,EAS2B,CAT3B,EAUlB,CAVkB,EAUf,CAVe,EAUZ,CAVY,EAUT,CAVS,EAUN,CAVM,EAUH,CAVG,EAUA,CAVA,EAUG,CAVH,EAUM,CAVN,EAUS,CAVT,EAUY,CAVZ,EAUe,CAVf,EAUkB,CAVlB,EAUqB,CAVrB,EAUwB,CAVxB,EAU2B,CAV3B,EAWlB,CAXkB,EAWf,CAXe,EAWZ,CAXY,EAWT,CAXS,EAWN,CAXM,EAWH,CAXG,EAWA,CAXA,EAWG,CAXH,EAWM,CAXN,EAWS,CAXT,EAWY,CAXZ,EAWe,CAXf,EAWkB,CAXlB,EAWqB,CAXrB,EAWwB,CAXxB,EAW2B,CAX3B,EAYlB,CAZkB,EAYf,CAZe,EAYZ,CAZY,EAYT,CAZS,EAYN,CAZM,EAYH,CAZG,EAYA,CAZA,EAYG,CAZH,EAYM,CAZN,EAYS,CAZT,EAYY,CAZZ,EAYe,CAZf,EAYkB,CAZlB,EAYqB,CAZrB,EAYwB,CAZxB,EAY2B,CAZ3B,EAalB,CAbkB,EAaf,CAbe,EAaZ,CAbY,EAaT,CAbS,EAaN,CAbM,EAaH,CAbG,EAaA,CAbA,EAaG,CAbH,EAaM,CAbN,EAaS,CAbT,EAaY,CAbZ,EAae,CAbf,EAakB,CAblB,EAaqB,CAbrB,EAawB,CAbxB,EAa2B,CAb3B,EAclB,CAdkB,EAcf,CAde,EAcZ,CAdY,EAcT,CAdS,EAcN,CAdM,EAcH,CAdG,EAcA,CAdA,EAcG,CAdH,EAcM,CAdN,EAcS,CAdT,EAcY,CAdZ,EAce,CAdf,EAckB,CAdlB,EAcqB,CAdrB,EAcwB,CAdxB,EAc2B,CAd3B,EAelB,CAfkB,EAef,CAfe,EAeZ,CAfY,EAeT,CAfS,EAeN,CAfM,EAeH,CAfG,EAeA,CAfA,EAeG,CAfH,EAeM,CAfN,EAeS,CAfT,EAeY,CAfZ,EAee,CAff,EAekB,CAflB,EAeqB,CAfrB,EAewB,CAfxB,EAe2B,CAf3B,EAgBlB,CAhBkB,EAgBf,CAhBe,EAgBZ,CAhBY,EAgBT,CAhBS,EAgBN,CAhBM,EAgBH,CAhBG,EAgBA,CAhBA,EAgBG,CAhBH,EAgBM,CAhBN,EAgBS,CAhBT,EAgBY,CAhBZ,EAgBe,CAhBf,EAgBkB,CAhBlB,EAgBqB,CAhBrB,EAgBwB,CAhBxB,EAgB2B,CAhB3B,CAgB6B;AAhB7B,CAAtB;;AAkBA,SAASvG,sBAAT,CAAgCwG,GAAhC,EAAqC;AACjCA,EAAAA,GAAG,IAAI,EAAP;AACA,MAAIA,GAAG,CAACnB,MAAJ,GAAa,CAAjB,EACI,OAAO,KAAP;;AACJ,MAAI,CAACkB,aAAa,CAACC,GAAG,CAACC,UAAJ,CAAe,CAAf,CAAD,CAAlB,EAAuC;AACnCjJ,IAAAA,KAAK,CAAC,oCAAD,EAAuCgJ,GAAG,CAACC,UAAJ,CAAe,CAAf,CAAvC,CAAL;AACA,WAAO,IAAP;AACH;;AACD,MAAID,GAAG,CAACnB,MAAJ,GAAa,CAAjB,EACI,OAAO,KAAP;;AACJ,MAAI,CAACkB,aAAa,CAACC,GAAG,CAACC,UAAJ,CAAe,CAAf,CAAD,CAAlB,EAAuC;AACnCjJ,IAAAA,KAAK,CAAC,oCAAD,EAAuCgJ,GAAG,CAACC,UAAJ,CAAe,CAAf,CAAvC,CAAL;AACA,WAAO,IAAP;AACH;;AACD,MAAID,GAAG,CAACnB,MAAJ,GAAa,CAAjB,EACI,OAAO,KAAP;;AACJ,MAAI,CAACkB,aAAa,CAACC,GAAG,CAACC,UAAJ,CAAe,CAAf,CAAD,CAAlB,EAAuC;AACnCjJ,IAAAA,KAAK,CAAC,oCAAD,EAAuCgJ,GAAG,CAACC,UAAJ,CAAe,CAAf,CAAvC,CAAL;AACA,WAAO,IAAP;AACH;;AACD,MAAID,GAAG,CAACnB,MAAJ,GAAa,CAAjB,EACI,OAAO,KAAP;;AACJ,MAAI,CAACkB,aAAa,CAACC,GAAG,CAACC,UAAJ,CAAe,CAAf,CAAD,CAAlB,EAAuC;AACnCjJ,IAAAA,KAAK,CAAC,oCAAD,EAAuCgJ,GAAG,CAACC,UAAJ,CAAe,CAAf,CAAvC,CAAL;AACA,WAAO,IAAP;AACH;;AACD,OAAK,IAAI1F,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyF,GAAG,CAACnB,MAAxB,EAAgC,EAAEtE,CAAlC,EAAqC;AACjC,QAAI,CAACwF,aAAa,CAACC,GAAG,CAACC,UAAJ,CAAe1F,CAAf,CAAD,CAAlB,EAAuC;AACnCvD,MAAAA,KAAK,CAAC,uCAAD,EAA0CuD,CAA1C,EAA6CyF,GAAG,CAACC,UAAJ,CAAe1F,CAAf,CAA7C,CAAL;AACA,aAAO,IAAP;AACH;AACJ;;AACD,SAAO,KAAP;AACH","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Server = exports.BaseServer = void 0;\r\nconst qs = require(\"querystring\");\r\nconst url_1 = require(\"url\");\r\nconst base64id = require(\"base64id\");\r\nconst transports_1 = require(\"./transports\");\r\nconst events_1 = require(\"events\");\r\nconst socket_1 = require(\"./socket\");\r\nconst debug_1 = require(\"debug\");\r\nconst cookie_1 = require(\"cookie\");\r\nconst ws_1 = require(\"ws\");\r\nconst debug = (0, debug_1.default)(\"engine\");\r\nclass BaseServer extends events_1.EventEmitter {\r\n    /**\r\n     * Server constructor.\r\n     *\r\n     * @param {Object} opts - options\r\n     * @api public\r\n     */\r\n    constructor(opts = {}) {\r\n        super();\r\n        this.clients = {};\r\n        this.clientsCount = 0;\r\n        this.opts = Object.assign({\r\n            wsEngine: ws_1.Server,\r\n            pingTimeout: 20000,\r\n            pingInterval: 25000,\r\n            upgradeTimeout: 10000,\r\n            maxHttpBufferSize: 1e6,\r\n            transports: Object.keys(transports_1.default),\r\n            allowUpgrades: true,\r\n            httpCompression: {\r\n                threshold: 1024\r\n            },\r\n            cors: false,\r\n            allowEIO3: false\r\n        }, opts);\r\n        if (opts.cookie) {\r\n            this.opts.cookie = Object.assign({\r\n                name: \"io\",\r\n                path: \"/\",\r\n                // @ts-ignore\r\n                httpOnly: opts.cookie.path !== false,\r\n                sameSite: \"lax\"\r\n            }, opts.cookie);\r\n        }\r\n        if (this.opts.cors) {\r\n            this.corsMiddleware = require(\"cors\")(this.opts.cors);\r\n        }\r\n        if (opts.perMessageDeflate) {\r\n            this.opts.perMessageDeflate = Object.assign({\r\n                threshold: 1024\r\n            }, opts.perMessageDeflate);\r\n        }\r\n        this.init();\r\n    }\r\n    /**\r\n     * Returns a list of available transports for upgrade given a certain transport.\r\n     *\r\n     * @return {Array}\r\n     * @api public\r\n     */\r\n    upgrades(transport) {\r\n        if (!this.opts.allowUpgrades)\r\n            return [];\r\n        return transports_1.default[transport].upgradesTo || [];\r\n    }\r\n    /**\r\n     * Verifies a request.\r\n     *\r\n     * @param {http.IncomingMessage}\r\n     * @return {Boolean} whether the request is valid\r\n     * @api private\r\n     */\r\n    verify(req, upgrade, fn) {\r\n        // transport check\r\n        const transport = req._query.transport;\r\n        if (!~this.opts.transports.indexOf(transport)) {\r\n            debug('unknown transport \"%s\"', transport);\r\n            return fn(Server.errors.UNKNOWN_TRANSPORT, { transport });\r\n        }\r\n        // 'Origin' header check\r\n        const isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);\r\n        if (isOriginInvalid) {\r\n            const origin = req.headers.origin;\r\n            req.headers.origin = null;\r\n            debug(\"origin header invalid\");\r\n            return fn(Server.errors.BAD_REQUEST, {\r\n                name: \"INVALID_ORIGIN\",\r\n                origin\r\n            });\r\n        }\r\n        // sid check\r\n        const sid = req._query.sid;\r\n        if (sid) {\r\n            if (!this.clients.hasOwnProperty(sid)) {\r\n                debug('unknown sid \"%s\"', sid);\r\n                return fn(Server.errors.UNKNOWN_SID, {\r\n                    sid\r\n                });\r\n            }\r\n            const previousTransport = this.clients[sid].transport.name;\r\n            if (!upgrade && previousTransport !== transport) {\r\n                debug(\"bad request: unexpected transport without upgrade\");\r\n                return fn(Server.errors.BAD_REQUEST, {\r\n                    name: \"TRANSPORT_MISMATCH\",\r\n                    transport,\r\n                    previousTransport\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            // handshake is GET only\r\n            if (\"GET\" !== req.method) {\r\n                return fn(Server.errors.BAD_HANDSHAKE_METHOD, {\r\n                    method: req.method\r\n                });\r\n            }\r\n            if (transport === \"websocket\" && !upgrade) {\r\n                debug(\"invalid transport upgrade\");\r\n                return fn(Server.errors.BAD_REQUEST, {\r\n                    name: \"TRANSPORT_HANDSHAKE_ERROR\"\r\n                });\r\n            }\r\n            if (!this.opts.allowRequest)\r\n                return fn();\r\n            return this.opts.allowRequest(req, (message, success) => {\r\n                if (!success) {\r\n                    return fn(Server.errors.FORBIDDEN, {\r\n                        message\r\n                    });\r\n                }\r\n                fn();\r\n            });\r\n        }\r\n        fn();\r\n    }\r\n    /**\r\n     * Closes all clients.\r\n     *\r\n     * @api public\r\n     */\r\n    close() {\r\n        debug(\"closing all open clients\");\r\n        for (let i in this.clients) {\r\n            if (this.clients.hasOwnProperty(i)) {\r\n                this.clients[i].close(true);\r\n            }\r\n        }\r\n        this.cleanup();\r\n        return this;\r\n    }\r\n    /**\r\n     * generate a socket id.\r\n     * Overwrite this method to generate your custom socket id\r\n     *\r\n     * @param {Object} request object\r\n     * @api public\r\n     */\r\n    generateId(req) {\r\n        return base64id.generateId();\r\n    }\r\n    /**\r\n     * Handshakes a new client.\r\n     *\r\n     * @param {String} transport name\r\n     * @param {Object} request object\r\n     * @param {Function} closeConnection\r\n     *\r\n     * @api protected\r\n     */\r\n    async handshake(transportName, req, closeConnection) {\r\n        const protocol = req._query.EIO === \"4\" ? 4 : 3; // 3rd revision by default\r\n        if (protocol === 3 && !this.opts.allowEIO3) {\r\n            debug(\"unsupported protocol version\");\r\n            this.emit(\"connection_error\", {\r\n                req,\r\n                code: Server.errors.UNSUPPORTED_PROTOCOL_VERSION,\r\n                message: Server.errorMessages[Server.errors.UNSUPPORTED_PROTOCOL_VERSION],\r\n                context: {\r\n                    protocol\r\n                }\r\n            });\r\n            closeConnection(Server.errors.UNSUPPORTED_PROTOCOL_VERSION);\r\n            return;\r\n        }\r\n        let id;\r\n        try {\r\n            id = await this.generateId(req);\r\n        }\r\n        catch (e) {\r\n            debug(\"error while generating an id\");\r\n            this.emit(\"connection_error\", {\r\n                req,\r\n                code: Server.errors.BAD_REQUEST,\r\n                message: Server.errorMessages[Server.errors.BAD_REQUEST],\r\n                context: {\r\n                    name: \"ID_GENERATION_ERROR\",\r\n                    error: e\r\n                }\r\n            });\r\n            closeConnection(Server.errors.BAD_REQUEST);\r\n            return;\r\n        }\r\n        debug('handshaking client \"%s\"', id);\r\n        try {\r\n            var transport = this.createTransport(transportName, req);\r\n            if (\"polling\" === transportName) {\r\n                transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;\r\n                transport.httpCompression = this.opts.httpCompression;\r\n            }\r\n            else if (\"websocket\" === transportName) {\r\n                transport.perMessageDeflate = this.opts.perMessageDeflate;\r\n            }\r\n            if (req._query && req._query.b64) {\r\n                transport.supportsBinary = false;\r\n            }\r\n            else {\r\n                transport.supportsBinary = true;\r\n            }\r\n        }\r\n        catch (e) {\r\n            debug('error handshaking to transport \"%s\"', transportName);\r\n            this.emit(\"connection_error\", {\r\n                req,\r\n                code: Server.errors.BAD_REQUEST,\r\n                message: Server.errorMessages[Server.errors.BAD_REQUEST],\r\n                context: {\r\n                    name: \"TRANSPORT_HANDSHAKE_ERROR\",\r\n                    error: e\r\n                }\r\n            });\r\n            closeConnection(Server.errors.BAD_REQUEST);\r\n            return;\r\n        }\r\n        const socket = new socket_1.Socket(id, this, transport, req, protocol);\r\n        transport.on(\"headers\", (headers, req) => {\r\n            const isInitialRequest = !req._query.sid;\r\n            if (isInitialRequest) {\r\n                if (this.opts.cookie) {\r\n                    headers[\"Set-Cookie\"] = [\r\n                        // @ts-ignore\r\n                        (0, cookie_1.serialize)(this.opts.cookie.name, id, this.opts.cookie)\r\n                    ];\r\n                }\r\n                this.emit(\"initial_headers\", headers, req);\r\n            }\r\n            this.emit(\"headers\", headers, req);\r\n        });\r\n        transport.onRequest(req);\r\n        this.clients[id] = socket;\r\n        this.clientsCount++;\r\n        socket.once(\"close\", () => {\r\n            delete this.clients[id];\r\n            this.clientsCount--;\r\n        });\r\n        this.emit(\"connection\", socket);\r\n        return transport;\r\n    }\r\n}\r\nexports.BaseServer = BaseServer;\r\n/**\r\n * Protocol errors mappings.\r\n */\r\nBaseServer.errors = {\r\n    UNKNOWN_TRANSPORT: 0,\r\n    UNKNOWN_SID: 1,\r\n    BAD_HANDSHAKE_METHOD: 2,\r\n    BAD_REQUEST: 3,\r\n    FORBIDDEN: 4,\r\n    UNSUPPORTED_PROTOCOL_VERSION: 5\r\n};\r\nBaseServer.errorMessages = {\r\n    0: \"Transport unknown\",\r\n    1: \"Session ID unknown\",\r\n    2: \"Bad handshake method\",\r\n    3: \"Bad request\",\r\n    4: \"Forbidden\",\r\n    5: \"Unsupported protocol version\"\r\n};\r\nclass Server extends BaseServer {\r\n    /**\r\n     * Initialize websocket server\r\n     *\r\n     * @api protected\r\n     */\r\n    init() {\r\n        if (!~this.opts.transports.indexOf(\"websocket\"))\r\n            return;\r\n        if (this.ws)\r\n            this.ws.close();\r\n        this.ws = new this.opts.wsEngine({\r\n            noServer: true,\r\n            clientTracking: false,\r\n            perMessageDeflate: this.opts.perMessageDeflate,\r\n            maxPayload: this.opts.maxHttpBufferSize\r\n        });\r\n        if (typeof this.ws.on === \"function\") {\r\n            this.ws.on(\"headers\", (headersArray, req) => {\r\n                // note: 'ws' uses an array of headers, while Engine.IO uses an object (response.writeHead() accepts both formats)\r\n                // we could also try to parse the array and then sync the values, but that will be error-prone\r\n                const additionalHeaders = {};\r\n                const isInitialRequest = !req._query.sid;\r\n                if (isInitialRequest) {\r\n                    this.emit(\"initial_headers\", additionalHeaders, req);\r\n                }\r\n                this.emit(\"headers\", additionalHeaders, req);\r\n                Object.keys(additionalHeaders).forEach(key => {\r\n                    headersArray.push(`${key}: ${additionalHeaders[key]}`);\r\n                });\r\n            });\r\n        }\r\n    }\r\n    cleanup() {\r\n        if (this.ws) {\r\n            debug(\"closing webSocketServer\");\r\n            this.ws.close();\r\n            // don't delete this.ws because it can be used again if the http server starts listening again\r\n        }\r\n    }\r\n    /**\r\n     * Prepares a request by processing the query string.\r\n     *\r\n     * @api private\r\n     */\r\n    prepare(req) {\r\n        // try to leverage pre-existing `req._query` (e.g: from connect)\r\n        if (!req._query) {\r\n            req._query = ~req.url.indexOf(\"?\") ? qs.parse((0, url_1.parse)(req.url).query) : {};\r\n        }\r\n    }\r\n    createTransport(transportName, req) {\r\n        return new transports_1.default[transportName](req);\r\n    }\r\n    /**\r\n     * Handles an Engine.IO HTTP request.\r\n     *\r\n     * @param {http.IncomingMessage} request\r\n     * @param {http.ServerResponse|http.OutgoingMessage} response\r\n     * @api public\r\n     */\r\n    handleRequest(req, res) {\r\n        debug('handling \"%s\" http request \"%s\"', req.method, req.url);\r\n        this.prepare(req);\r\n        req.res = res;\r\n        const callback = (errorCode, errorContext) => {\r\n            if (errorCode !== undefined) {\r\n                this.emit(\"connection_error\", {\r\n                    req,\r\n                    code: errorCode,\r\n                    message: Server.errorMessages[errorCode],\r\n                    context: errorContext\r\n                });\r\n                abortRequest(res, errorCode, errorContext);\r\n                return;\r\n            }\r\n            if (req._query.sid) {\r\n                debug(\"setting new request for existing client\");\r\n                this.clients[req._query.sid].transport.onRequest(req);\r\n            }\r\n            else {\r\n                const closeConnection = (errorCode, errorContext) => abortRequest(res, errorCode, errorContext);\r\n                this.handshake(req._query.transport, req, closeConnection);\r\n            }\r\n        };\r\n        if (this.corsMiddleware) {\r\n            this.corsMiddleware.call(null, req, res, () => {\r\n                this.verify(req, false, callback);\r\n            });\r\n        }\r\n        else {\r\n            this.verify(req, false, callback);\r\n        }\r\n    }\r\n    /**\r\n     * Handles an Engine.IO HTTP Upgrade.\r\n     *\r\n     * @api public\r\n     */\r\n    handleUpgrade(req, socket, upgradeHead) {\r\n        this.prepare(req);\r\n        this.verify(req, true, (errorCode, errorContext) => {\r\n            if (errorCode) {\r\n                this.emit(\"connection_error\", {\r\n                    req,\r\n                    code: errorCode,\r\n                    message: Server.errorMessages[errorCode],\r\n                    context: errorContext\r\n                });\r\n                abortUpgrade(socket, errorCode, errorContext);\r\n                return;\r\n            }\r\n            const head = Buffer.from(upgradeHead); // eslint-disable-line node/no-deprecated-api\r\n            upgradeHead = null;\r\n            // delegate to ws\r\n            this.ws.handleUpgrade(req, socket, head, websocket => {\r\n                this.onWebSocket(req, socket, websocket);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Called upon a ws.io connection.\r\n     *\r\n     * @param {ws.Socket} websocket\r\n     * @api private\r\n     */\r\n    onWebSocket(req, socket, websocket) {\r\n        websocket.on(\"error\", onUpgradeError);\r\n        if (transports_1.default[req._query.transport] !== undefined &&\r\n            !transports_1.default[req._query.transport].prototype.handlesUpgrades) {\r\n            debug(\"transport doesnt handle upgraded requests\");\r\n            websocket.close();\r\n            return;\r\n        }\r\n        // get client id\r\n        const id = req._query.sid;\r\n        // keep a reference to the ws.Socket\r\n        req.websocket = websocket;\r\n        if (id) {\r\n            const client = this.clients[id];\r\n            if (!client) {\r\n                debug(\"upgrade attempt for closed client\");\r\n                websocket.close();\r\n            }\r\n            else if (client.upgrading) {\r\n                debug(\"transport has already been trying to upgrade\");\r\n                websocket.close();\r\n            }\r\n            else if (client.upgraded) {\r\n                debug(\"transport had already been upgraded\");\r\n                websocket.close();\r\n            }\r\n            else {\r\n                debug(\"upgrading existing transport\");\r\n                // transport error handling takes over\r\n                websocket.removeListener(\"error\", onUpgradeError);\r\n                const transport = this.createTransport(req._query.transport, req);\r\n                if (req._query && req._query.b64) {\r\n                    transport.supportsBinary = false;\r\n                }\r\n                else {\r\n                    transport.supportsBinary = true;\r\n                }\r\n                transport.perMessageDeflate = this.opts.perMessageDeflate;\r\n                client.maybeUpgrade(transport);\r\n            }\r\n        }\r\n        else {\r\n            const closeConnection = (errorCode, errorContext) => abortUpgrade(socket, errorCode, errorContext);\r\n            this.handshake(req._query.transport, req, closeConnection);\r\n        }\r\n        function onUpgradeError() {\r\n            debug(\"websocket error before upgrade\");\r\n            // websocket.close() not needed\r\n        }\r\n    }\r\n    /**\r\n     * Captures upgrade requests for a http.Server.\r\n     *\r\n     * @param {http.Server} server\r\n     * @param {Object} options\r\n     * @api public\r\n     */\r\n    attach(server, options = {}) {\r\n        let path = (options.path || \"/engine.io\").replace(/\\/$/, \"\");\r\n        const destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000;\r\n        // normalize path\r\n        path += \"/\";\r\n        function check(req) {\r\n            return path === req.url.substr(0, path.length);\r\n        }\r\n        // cache and clean up listeners\r\n        const listeners = server.listeners(\"request\").slice(0);\r\n        server.removeAllListeners(\"request\");\r\n        server.on(\"close\", this.close.bind(this));\r\n        server.on(\"listening\", this.init.bind(this));\r\n        // add request handler\r\n        server.on(\"request\", (req, res) => {\r\n            if (check(req)) {\r\n                debug('intercepting request for path \"%s\"', path);\r\n                this.handleRequest(req, res);\r\n            }\r\n            else {\r\n                let i = 0;\r\n                const l = listeners.length;\r\n                for (; i < l; i++) {\r\n                    listeners[i].call(server, req, res);\r\n                }\r\n            }\r\n        });\r\n        if (~this.opts.transports.indexOf(\"websocket\")) {\r\n            server.on(\"upgrade\", (req, socket, head) => {\r\n                if (check(req)) {\r\n                    this.handleUpgrade(req, socket, head);\r\n                }\r\n                else if (false !== options.destroyUpgrade) {\r\n                    // default node behavior is to disconnect when no handlers\r\n                    // but by adding a handler, we prevent that\r\n                    // and if no eio thing handles the upgrade\r\n                    // then the socket needs to die!\r\n                    setTimeout(function () {\r\n                        // @ts-ignore\r\n                        if (socket.writable && socket.bytesWritten <= 0) {\r\n                            return socket.end();\r\n                        }\r\n                    }, destroyUpgradeTimeout);\r\n                }\r\n            });\r\n        }\r\n    }\r\n}\r\nexports.Server = Server;\r\n/**\r\n * Close the HTTP long-polling request\r\n *\r\n * @param res - the response object\r\n * @param errorCode - the error code\r\n * @param errorContext - additional error context\r\n *\r\n * @api private\r\n */\r\nfunction abortRequest(res, errorCode, errorContext) {\r\n    const statusCode = errorCode === Server.errors.FORBIDDEN ? 403 : 400;\r\n    const message = errorContext && errorContext.message\r\n        ? errorContext.message\r\n        : Server.errorMessages[errorCode];\r\n    res.writeHead(statusCode, { \"Content-Type\": \"application/json\" });\r\n    res.end(JSON.stringify({\r\n        code: errorCode,\r\n        message\r\n    }));\r\n}\r\n/**\r\n * Close the WebSocket connection\r\n *\r\n * @param {net.Socket} socket\r\n * @param {string} errorCode - the error code\r\n * @param {object} errorContext - additional error context\r\n *\r\n * @api private\r\n */\r\nfunction abortUpgrade(socket, errorCode, errorContext = {}) {\r\n    socket.on(\"error\", () => {\r\n        debug(\"ignoring error from closed connection\");\r\n    });\r\n    if (socket.writable) {\r\n        const message = errorContext.message || Server.errorMessages[errorCode];\r\n        const length = Buffer.byteLength(message);\r\n        socket.write(\"HTTP/1.1 400 Bad Request\\r\\n\" +\r\n            \"Connection: close\\r\\n\" +\r\n            \"Content-type: text/html\\r\\n\" +\r\n            \"Content-Length: \" +\r\n            length +\r\n            \"\\r\\n\" +\r\n            \"\\r\\n\" +\r\n            message);\r\n    }\r\n    socket.destroy();\r\n}\r\n/* eslint-disable */\r\n/**\r\n * From https://github.com/nodejs/node/blob/v8.4.0/lib/_http_common.js#L303-L354\r\n *\r\n * True if val contains an invalid field-vchar\r\n *  field-value    = *( field-content / obs-fold )\r\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\r\n *  field-vchar    = VCHAR / obs-text\r\n *\r\n * checkInvalidHeaderChar() is currently designed to be inlinable by v8,\r\n * so take care when making changes to the implementation so that the source\r\n * code size does not exceed v8's default max_inlined_source_size setting.\r\n **/\r\n// prettier-ignore\r\nconst validHdrChars = [\r\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,\r\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,\r\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // ... 255\r\n];\r\nfunction checkInvalidHeaderChar(val) {\r\n    val += \"\";\r\n    if (val.length < 1)\r\n        return false;\r\n    if (!validHdrChars[val.charCodeAt(0)]) {\r\n        debug('invalid header, index 0, char \"%s\"', val.charCodeAt(0));\r\n        return true;\r\n    }\r\n    if (val.length < 2)\r\n        return false;\r\n    if (!validHdrChars[val.charCodeAt(1)]) {\r\n        debug('invalid header, index 1, char \"%s\"', val.charCodeAt(1));\r\n        return true;\r\n    }\r\n    if (val.length < 3)\r\n        return false;\r\n    if (!validHdrChars[val.charCodeAt(2)]) {\r\n        debug('invalid header, index 2, char \"%s\"', val.charCodeAt(2));\r\n        return true;\r\n    }\r\n    if (val.length < 4)\r\n        return false;\r\n    if (!validHdrChars[val.charCodeAt(3)]) {\r\n        debug('invalid header, index 3, char \"%s\"', val.charCodeAt(3));\r\n        return true;\r\n    }\r\n    for (let i = 4; i < val.length; ++i) {\r\n        if (!validHdrChars[val.charCodeAt(i)]) {\r\n            debug('invalid header, index \"%i\", char \"%s\"', i, val.charCodeAt(i));\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n"]},"metadata":{},"sourceType":"script"}