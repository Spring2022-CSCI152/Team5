{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ParentNamespace = void 0;\n\nconst namespace_1 = require(\"./namespace\");\n\nclass ParentNamespace extends namespace_1.Namespace {\n  constructor(server) {\n    super(server, \"/_\" + ParentNamespace.count++);\n    this.children = new Set();\n  }\n  /**\r\n   * @private\r\n   */\n\n\n  _initAdapter() {\n    const broadcast = (packet, opts) => {\n      this.children.forEach(nsp => {\n        nsp.adapter.broadcast(packet, opts);\n      });\n    }; // @ts-ignore FIXME is there a way to declare an inner class in TypeScript?\n\n\n    this.adapter = {\n      broadcast\n    };\n  }\n\n  emit(ev) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    this.children.forEach(nsp => {\n      nsp.emit(ev, ...args);\n    });\n    return true;\n  }\n\n  createChild(name) {\n    const namespace = new namespace_1.Namespace(this.server, name);\n    namespace._fns = this._fns.slice(0);\n    this.listeners(\"connect\").forEach(listener => namespace.on(\"connect\", listener));\n    this.listeners(\"connection\").forEach(listener => namespace.on(\"connection\", listener));\n    this.children.add(namespace);\n\n    this.server._nsps.set(name, namespace);\n\n    return namespace;\n  }\n\n  fetchSockets() {\n    // note: we could make the fetchSockets() method work for dynamic namespaces created with a regex (by sending the\n    // regex to the other Socket.IO servers, and returning the sockets of each matching namespace for example), but\n    // the behavior for namespaces created with a function is less clear\n    // note²: we cannot loop over each children namespace, because with multiple Socket.IO servers, a given namespace\n    // may exist on one node but not exist on another (since it is created upon client connection)\n    throw new Error(\"fetchSockets() is not supported on parent namespaces\");\n  }\n\n}\n\nexports.ParentNamespace = ParentNamespace;\nParentNamespace.count = 0;","map":{"version":3,"sources":["C:/Users/gabe/Desktop/Pomo/Team5/client/node_modules/socket.io/dist/parent-namespace.js"],"names":["Object","defineProperty","exports","value","ParentNamespace","namespace_1","require","Namespace","constructor","server","count","children","Set","_initAdapter","broadcast","packet","opts","forEach","nsp","adapter","emit","ev","args","createChild","name","namespace","_fns","slice","listeners","listener","on","add","_nsps","set","fetchSockets","Error"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,eAAR,GAA0B,KAAK,CAA/B;;AACA,MAAMC,WAAW,GAAGC,OAAO,CAAC,aAAD,CAA3B;;AACA,MAAMF,eAAN,SAA8BC,WAAW,CAACE,SAA1C,CAAoD;AAChDC,EAAAA,WAAW,CAACC,MAAD,EAAS;AAChB,UAAMA,MAAN,EAAc,OAAOL,eAAe,CAACM,KAAhB,EAArB;AACA,SAAKC,QAAL,GAAgB,IAAIC,GAAJ,EAAhB;AACH;AACD;AACJ;AACA;;;AACIC,EAAAA,YAAY,GAAG;AACX,UAAMC,SAAS,GAAG,CAACC,MAAD,EAASC,IAAT,KAAkB;AAChC,WAAKL,QAAL,CAAcM,OAAd,CAAuBC,GAAD,IAAS;AAC3BA,QAAAA,GAAG,CAACC,OAAJ,CAAYL,SAAZ,CAAsBC,MAAtB,EAA8BC,IAA9B;AACH,OAFD;AAGH,KAJD,CADW,CAMX;;;AACA,SAAKG,OAAL,GAAe;AAAEL,MAAAA;AAAF,KAAf;AACH;;AACDM,EAAAA,IAAI,CAACC,EAAD,EAAc;AAAA,sCAANC,IAAM;AAANA,MAAAA,IAAM;AAAA;;AACd,SAAKX,QAAL,CAAcM,OAAd,CAAuBC,GAAD,IAAS;AAC3BA,MAAAA,GAAG,CAACE,IAAJ,CAASC,EAAT,EAAa,GAAGC,IAAhB;AACH,KAFD;AAGA,WAAO,IAAP;AACH;;AACDC,EAAAA,WAAW,CAACC,IAAD,EAAO;AACd,UAAMC,SAAS,GAAG,IAAIpB,WAAW,CAACE,SAAhB,CAA0B,KAAKE,MAA/B,EAAuCe,IAAvC,CAAlB;AACAC,IAAAA,SAAS,CAACC,IAAV,GAAiB,KAAKA,IAAL,CAAUC,KAAV,CAAgB,CAAhB,CAAjB;AACA,SAAKC,SAAL,CAAe,SAAf,EAA0BX,OAA1B,CAAmCY,QAAD,IAAcJ,SAAS,CAACK,EAAV,CAAa,SAAb,EAAwBD,QAAxB,CAAhD;AACA,SAAKD,SAAL,CAAe,YAAf,EAA6BX,OAA7B,CAAsCY,QAAD,IAAcJ,SAAS,CAACK,EAAV,CAAa,YAAb,EAA2BD,QAA3B,CAAnD;AACA,SAAKlB,QAAL,CAAcoB,GAAd,CAAkBN,SAAlB;;AACA,SAAKhB,MAAL,CAAYuB,KAAZ,CAAkBC,GAAlB,CAAsBT,IAAtB,EAA4BC,SAA5B;;AACA,WAAOA,SAAP;AACH;;AACDS,EAAAA,YAAY,GAAG;AACX;AACA;AACA;AACA;AACA;AACA,UAAM,IAAIC,KAAJ,CAAU,sDAAV,CAAN;AACH;;AAvC+C;;AAyCpDjC,OAAO,CAACE,eAAR,GAA0BA,eAA1B;AACAA,eAAe,CAACM,KAAhB,GAAwB,CAAxB","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ParentNamespace = void 0;\r\nconst namespace_1 = require(\"./namespace\");\r\nclass ParentNamespace extends namespace_1.Namespace {\r\n    constructor(server) {\r\n        super(server, \"/_\" + ParentNamespace.count++);\r\n        this.children = new Set();\r\n    }\r\n    /**\r\n     * @private\r\n     */\r\n    _initAdapter() {\r\n        const broadcast = (packet, opts) => {\r\n            this.children.forEach((nsp) => {\r\n                nsp.adapter.broadcast(packet, opts);\r\n            });\r\n        };\r\n        // @ts-ignore FIXME is there a way to declare an inner class in TypeScript?\r\n        this.adapter = { broadcast };\r\n    }\r\n    emit(ev, ...args) {\r\n        this.children.forEach((nsp) => {\r\n            nsp.emit(ev, ...args);\r\n        });\r\n        return true;\r\n    }\r\n    createChild(name) {\r\n        const namespace = new namespace_1.Namespace(this.server, name);\r\n        namespace._fns = this._fns.slice(0);\r\n        this.listeners(\"connect\").forEach((listener) => namespace.on(\"connect\", listener));\r\n        this.listeners(\"connection\").forEach((listener) => namespace.on(\"connection\", listener));\r\n        this.children.add(namespace);\r\n        this.server._nsps.set(name, namespace);\r\n        return namespace;\r\n    }\r\n    fetchSockets() {\r\n        // note: we could make the fetchSockets() method work for dynamic namespaces created with a regex (by sending the\r\n        // regex to the other Socket.IO servers, and returning the sockets of each matching namespace for example), but\r\n        // the behavior for namespaces created with a function is less clear\r\n        // note²: we cannot loop over each children namespace, because with multiple Socket.IO servers, a given namespace\r\n        // may exist on one node but not exist on another (since it is created upon client connection)\r\n        throw new Error(\"fetchSockets() is not supported on parent namespaces\");\r\n    }\r\n}\r\nexports.ParentNamespace = ParentNamespace;\r\nParentNamespace.count = 0;\r\n"]},"metadata":{},"sourceType":"script"}