{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Client = void 0;\n\nconst socket_io_parser_1 = require(\"socket.io-parser\");\n\nconst debugModule = require(\"debug\");\n\nconst url = require(\"url\");\n\nconst debug = debugModule(\"socket.io:client\");\n\nclass Client {\n  /**\r\n   * Client constructor.\r\n   *\r\n   * @param server instance\r\n   * @param conn\r\n   * @package\r\n   */\n  constructor(server, conn) {\n    this.sockets = new Map();\n    this.nsps = new Map();\n    this.server = server;\n    this.conn = conn;\n    this.encoder = server.encoder;\n    this.decoder = new server._parser.Decoder();\n    this.id = conn.id;\n    this.setup();\n  }\n  /**\r\n   * @return the reference to the request that originated the Engine.IO connection\r\n   *\r\n   * @public\r\n   */\n\n\n  get request() {\n    return this.conn.request;\n  }\n  /**\r\n   * Sets up event listeners.\r\n   *\r\n   * @private\r\n   */\n\n\n  setup() {\n    this.onclose = this.onclose.bind(this);\n    this.ondata = this.ondata.bind(this);\n    this.onerror = this.onerror.bind(this);\n    this.ondecoded = this.ondecoded.bind(this); // @ts-ignore\n\n    this.decoder.on(\"decoded\", this.ondecoded);\n    this.conn.on(\"data\", this.ondata);\n    this.conn.on(\"error\", this.onerror);\n    this.conn.on(\"close\", this.onclose);\n    this.connectTimeout = setTimeout(() => {\n      if (this.nsps.size === 0) {\n        debug(\"no namespace joined yet, close the client\");\n        this.close();\n      } else {\n        debug(\"the client has already joined a namespace, nothing to do\");\n      }\n    }, this.server._connectTimeout);\n  }\n  /**\r\n   * Connects a client to a namespace.\r\n   *\r\n   * @param {String} name - the namespace\r\n   * @param {Object} auth - the auth parameters\r\n   * @private\r\n   */\n\n\n  connect(name) {\n    let auth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (this.server._nsps.has(name)) {\n      debug(\"connecting to namespace %s\", name);\n      return this.doConnect(name, auth);\n    }\n\n    this.server._checkNamespace(name, auth, dynamicNspName => {\n      if (dynamicNspName) {\n        this.doConnect(name, auth);\n      } else {\n        debug(\"creation of namespace %s was denied\", name);\n\n        this._packet({\n          type: socket_io_parser_1.PacketType.CONNECT_ERROR,\n          nsp: name,\n          data: {\n            message: \"Invalid namespace\"\n          }\n        });\n      }\n    });\n  }\n  /**\r\n   * Connects a client to a namespace.\r\n   *\r\n   * @param name - the namespace\r\n   * @param {Object} auth - the auth parameters\r\n   *\r\n   * @private\r\n   */\n\n\n  doConnect(name, auth) {\n    const nsp = this.server.of(name);\n\n    const socket = nsp._add(this, auth, () => {\n      this.sockets.set(socket.id, socket);\n      this.nsps.set(nsp.name, socket);\n\n      if (this.connectTimeout) {\n        clearTimeout(this.connectTimeout);\n        this.connectTimeout = undefined;\n      }\n    });\n  }\n  /**\r\n   * Disconnects from all namespaces and closes transport.\r\n   *\r\n   * @private\r\n   */\n\n\n  _disconnect() {\n    for (const socket of this.sockets.values()) {\n      socket.disconnect();\n    }\n\n    this.sockets.clear();\n    this.close();\n  }\n  /**\r\n   * Removes a socket. Called by each `Socket`.\r\n   *\r\n   * @private\r\n   */\n\n\n  _remove(socket) {\n    if (this.sockets.has(socket.id)) {\n      const nsp = this.sockets.get(socket.id).nsp.name;\n      this.sockets.delete(socket.id);\n      this.nsps.delete(nsp);\n    } else {\n      debug(\"ignoring remove for %s\", socket.id);\n    }\n  }\n  /**\r\n   * Closes the underlying connection.\r\n   *\r\n   * @private\r\n   */\n\n\n  close() {\n    if (\"open\" === this.conn.readyState) {\n      debug(\"forcing transport close\");\n      this.conn.close();\n      this.onclose(\"forced server close\");\n    }\n  }\n  /**\r\n   * Writes a packet to the transport.\r\n   *\r\n   * @param {Object} packet object\r\n   * @param {Object} opts\r\n   * @private\r\n   */\n\n\n  _packet(packet) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (this.conn.readyState !== \"open\") {\n      debug(\"ignoring packet write %j\", packet);\n      return;\n    }\n\n    const encodedPackets = opts.preEncoded ? packet // previous versions of the adapter incorrectly used socket.packet() instead of writeToEngine()\n    : this.encoder.encode(packet);\n    this.writeToEngine(encodedPackets, opts);\n  }\n\n  writeToEngine(encodedPackets, opts) {\n    if (opts.volatile && !this.conn.transport.writable) {\n      debug(\"volatile packet is discarded since the transport is not currently writable\");\n      return;\n    }\n\n    const packets = Array.isArray(encodedPackets) ? encodedPackets : [encodedPackets];\n\n    for (const encodedPacket of packets) {\n      this.conn.write(encodedPacket, opts);\n    }\n  }\n  /**\r\n   * Called with incoming transport data.\r\n   *\r\n   * @private\r\n   */\n\n\n  ondata(data) {\n    // try/catch is needed for protocol violations (GH-1880)\n    try {\n      this.decoder.add(data);\n    } catch (e) {\n      this.onerror(e);\n    }\n  }\n  /**\r\n   * Called when parser fully decodes a packet.\r\n   *\r\n   * @private\r\n   */\n\n\n  ondecoded(packet) {\n    if (socket_io_parser_1.PacketType.CONNECT === packet.type) {\n      if (this.conn.protocol === 3) {\n        const parsed = url.parse(packet.nsp, true);\n        this.connect(parsed.pathname, parsed.query);\n      } else {\n        this.connect(packet.nsp, packet.data);\n      }\n    } else {\n      const socket = this.nsps.get(packet.nsp);\n\n      if (socket) {\n        process.nextTick(function () {\n          socket._onpacket(packet);\n        });\n      } else {\n        debug(\"no socket for namespace %s\", packet.nsp);\n      }\n    }\n  }\n  /**\r\n   * Handles an error.\r\n   *\r\n   * @param {Object} err object\r\n   * @private\r\n   */\n\n\n  onerror(err) {\n    for (const socket of this.sockets.values()) {\n      socket._onerror(err);\n    }\n\n    this.conn.close();\n  }\n  /**\r\n   * Called upon transport close.\r\n   *\r\n   * @param reason\r\n   * @private\r\n   */\n\n\n  onclose(reason) {\n    debug(\"client close with reason %s\", reason); // ignore a potential subsequent `close` event\n\n    this.destroy(); // `nsps` and `sockets` are cleaned up seamlessly\n\n    for (const socket of this.sockets.values()) {\n      socket._onclose(reason);\n    }\n\n    this.sockets.clear();\n    this.decoder.destroy(); // clean up decoder\n  }\n  /**\r\n   * Cleans up event listeners.\r\n   * @private\r\n   */\n\n\n  destroy() {\n    this.conn.removeListener(\"data\", this.ondata);\n    this.conn.removeListener(\"error\", this.onerror);\n    this.conn.removeListener(\"close\", this.onclose); // @ts-ignore\n\n    this.decoder.removeListener(\"decoded\", this.ondecoded);\n\n    if (this.connectTimeout) {\n      clearTimeout(this.connectTimeout);\n      this.connectTimeout = undefined;\n    }\n  }\n\n}\n\nexports.Client = Client;","map":{"version":3,"sources":["C:/Users/gabe/Desktop/Pomo/Team5/client/node_modules/socket.io/dist/client.js"],"names":["Object","defineProperty","exports","value","Client","socket_io_parser_1","require","debugModule","url","debug","constructor","server","conn","sockets","Map","nsps","encoder","decoder","_parser","Decoder","id","setup","request","onclose","bind","ondata","onerror","ondecoded","on","connectTimeout","setTimeout","size","close","_connectTimeout","connect","name","auth","_nsps","has","doConnect","_checkNamespace","dynamicNspName","_packet","type","PacketType","CONNECT_ERROR","nsp","data","message","of","socket","_add","set","clearTimeout","undefined","_disconnect","values","disconnect","clear","_remove","get","delete","readyState","packet","opts","encodedPackets","preEncoded","encode","writeToEngine","volatile","transport","writable","packets","Array","isArray","encodedPacket","write","add","e","CONNECT","protocol","parsed","parse","pathname","query","process","nextTick","_onpacket","err","_onerror","reason","destroy","_onclose","removeListener"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Client = void 0;\r\nconst socket_io_parser_1 = require(\"socket.io-parser\");\r\nconst debugModule = require(\"debug\");\r\nconst url = require(\"url\");\r\nconst debug = debugModule(\"socket.io:client\");\r\nclass Client {\r\n    /**\r\n     * Client constructor.\r\n     *\r\n     * @param server instance\r\n     * @param conn\r\n     * @package\r\n     */\r\n    constructor(server, conn) {\r\n        this.sockets = new Map();\r\n        this.nsps = new Map();\r\n        this.server = server;\r\n        this.conn = conn;\r\n        this.encoder = server.encoder;\r\n        this.decoder = new server._parser.Decoder();\r\n        this.id = conn.id;\r\n        this.setup();\r\n    }\r\n    /**\r\n     * @return the reference to the request that originated the Engine.IO connection\r\n     *\r\n     * @public\r\n     */\r\n    get request() {\r\n        return this.conn.request;\r\n    }\r\n    /**\r\n     * Sets up event listeners.\r\n     *\r\n     * @private\r\n     */\r\n    setup() {\r\n        this.onclose = this.onclose.bind(this);\r\n        this.ondata = this.ondata.bind(this);\r\n        this.onerror = this.onerror.bind(this);\r\n        this.ondecoded = this.ondecoded.bind(this);\r\n        // @ts-ignore\r\n        this.decoder.on(\"decoded\", this.ondecoded);\r\n        this.conn.on(\"data\", this.ondata);\r\n        this.conn.on(\"error\", this.onerror);\r\n        this.conn.on(\"close\", this.onclose);\r\n        this.connectTimeout = setTimeout(() => {\r\n            if (this.nsps.size === 0) {\r\n                debug(\"no namespace joined yet, close the client\");\r\n                this.close();\r\n            }\r\n            else {\r\n                debug(\"the client has already joined a namespace, nothing to do\");\r\n            }\r\n        }, this.server._connectTimeout);\r\n    }\r\n    /**\r\n     * Connects a client to a namespace.\r\n     *\r\n     * @param {String} name - the namespace\r\n     * @param {Object} auth - the auth parameters\r\n     * @private\r\n     */\r\n    connect(name, auth = {}) {\r\n        if (this.server._nsps.has(name)) {\r\n            debug(\"connecting to namespace %s\", name);\r\n            return this.doConnect(name, auth);\r\n        }\r\n        this.server._checkNamespace(name, auth, (dynamicNspName) => {\r\n            if (dynamicNspName) {\r\n                this.doConnect(name, auth);\r\n            }\r\n            else {\r\n                debug(\"creation of namespace %s was denied\", name);\r\n                this._packet({\r\n                    type: socket_io_parser_1.PacketType.CONNECT_ERROR,\r\n                    nsp: name,\r\n                    data: {\r\n                        message: \"Invalid namespace\",\r\n                    },\r\n                });\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Connects a client to a namespace.\r\n     *\r\n     * @param name - the namespace\r\n     * @param {Object} auth - the auth parameters\r\n     *\r\n     * @private\r\n     */\r\n    doConnect(name, auth) {\r\n        const nsp = this.server.of(name);\r\n        const socket = nsp._add(this, auth, () => {\r\n            this.sockets.set(socket.id, socket);\r\n            this.nsps.set(nsp.name, socket);\r\n            if (this.connectTimeout) {\r\n                clearTimeout(this.connectTimeout);\r\n                this.connectTimeout = undefined;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Disconnects from all namespaces and closes transport.\r\n     *\r\n     * @private\r\n     */\r\n    _disconnect() {\r\n        for (const socket of this.sockets.values()) {\r\n            socket.disconnect();\r\n        }\r\n        this.sockets.clear();\r\n        this.close();\r\n    }\r\n    /**\r\n     * Removes a socket. Called by each `Socket`.\r\n     *\r\n     * @private\r\n     */\r\n    _remove(socket) {\r\n        if (this.sockets.has(socket.id)) {\r\n            const nsp = this.sockets.get(socket.id).nsp.name;\r\n            this.sockets.delete(socket.id);\r\n            this.nsps.delete(nsp);\r\n        }\r\n        else {\r\n            debug(\"ignoring remove for %s\", socket.id);\r\n        }\r\n    }\r\n    /**\r\n     * Closes the underlying connection.\r\n     *\r\n     * @private\r\n     */\r\n    close() {\r\n        if (\"open\" === this.conn.readyState) {\r\n            debug(\"forcing transport close\");\r\n            this.conn.close();\r\n            this.onclose(\"forced server close\");\r\n        }\r\n    }\r\n    /**\r\n     * Writes a packet to the transport.\r\n     *\r\n     * @param {Object} packet object\r\n     * @param {Object} opts\r\n     * @private\r\n     */\r\n    _packet(packet, opts = {}) {\r\n        if (this.conn.readyState !== \"open\") {\r\n            debug(\"ignoring packet write %j\", packet);\r\n            return;\r\n        }\r\n        const encodedPackets = opts.preEncoded\r\n            ? packet // previous versions of the adapter incorrectly used socket.packet() instead of writeToEngine()\r\n            : this.encoder.encode(packet);\r\n        this.writeToEngine(encodedPackets, opts);\r\n    }\r\n    writeToEngine(encodedPackets, opts) {\r\n        if (opts.volatile && !this.conn.transport.writable) {\r\n            debug(\"volatile packet is discarded since the transport is not currently writable\");\r\n            return;\r\n        }\r\n        const packets = Array.isArray(encodedPackets)\r\n            ? encodedPackets\r\n            : [encodedPackets];\r\n        for (const encodedPacket of packets) {\r\n            this.conn.write(encodedPacket, opts);\r\n        }\r\n    }\r\n    /**\r\n     * Called with incoming transport data.\r\n     *\r\n     * @private\r\n     */\r\n    ondata(data) {\r\n        // try/catch is needed for protocol violations (GH-1880)\r\n        try {\r\n            this.decoder.add(data);\r\n        }\r\n        catch (e) {\r\n            this.onerror(e);\r\n        }\r\n    }\r\n    /**\r\n     * Called when parser fully decodes a packet.\r\n     *\r\n     * @private\r\n     */\r\n    ondecoded(packet) {\r\n        if (socket_io_parser_1.PacketType.CONNECT === packet.type) {\r\n            if (this.conn.protocol === 3) {\r\n                const parsed = url.parse(packet.nsp, true);\r\n                this.connect(parsed.pathname, parsed.query);\r\n            }\r\n            else {\r\n                this.connect(packet.nsp, packet.data);\r\n            }\r\n        }\r\n        else {\r\n            const socket = this.nsps.get(packet.nsp);\r\n            if (socket) {\r\n                process.nextTick(function () {\r\n                    socket._onpacket(packet);\r\n                });\r\n            }\r\n            else {\r\n                debug(\"no socket for namespace %s\", packet.nsp);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Handles an error.\r\n     *\r\n     * @param {Object} err object\r\n     * @private\r\n     */\r\n    onerror(err) {\r\n        for (const socket of this.sockets.values()) {\r\n            socket._onerror(err);\r\n        }\r\n        this.conn.close();\r\n    }\r\n    /**\r\n     * Called upon transport close.\r\n     *\r\n     * @param reason\r\n     * @private\r\n     */\r\n    onclose(reason) {\r\n        debug(\"client close with reason %s\", reason);\r\n        // ignore a potential subsequent `close` event\r\n        this.destroy();\r\n        // `nsps` and `sockets` are cleaned up seamlessly\r\n        for (const socket of this.sockets.values()) {\r\n            socket._onclose(reason);\r\n        }\r\n        this.sockets.clear();\r\n        this.decoder.destroy(); // clean up decoder\r\n    }\r\n    /**\r\n     * Cleans up event listeners.\r\n     * @private\r\n     */\r\n    destroy() {\r\n        this.conn.removeListener(\"data\", this.ondata);\r\n        this.conn.removeListener(\"error\", this.onerror);\r\n        this.conn.removeListener(\"close\", this.onclose);\r\n        // @ts-ignore\r\n        this.decoder.removeListener(\"decoded\", this.ondecoded);\r\n        if (this.connectTimeout) {\r\n            clearTimeout(this.connectTimeout);\r\n            this.connectTimeout = undefined;\r\n        }\r\n    }\r\n}\r\nexports.Client = Client;\r\n"]},"metadata":{},"sourceType":"script"}