{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StrictEventEmitter = void 0;\n\nconst events_1 = require(\"events\");\n/**\r\n * Strictly typed version of an `EventEmitter`. A `TypedEventEmitter` takes type\r\n * parameters for mappings of event names to event data types, and strictly\r\n * types method calls to the `EventEmitter` according to these event maps.\r\n *\r\n * @typeParam ListenEvents - `EventsMap` of user-defined events that can be\r\n * listened to with `on` or `once`\r\n * @typeParam EmitEvents - `EventsMap` of user-defined events that can be\r\n * emitted with `emit`\r\n * @typeParam ReservedEvents - `EventsMap` of reserved events, that can be\r\n * emitted by socket.io with `emitReserved`, and can be listened to with\r\n * `listen`.\r\n */\n\n\nclass StrictEventEmitter extends events_1.EventEmitter {\n  /**\r\n   * Adds the `listener` function as an event listener for `ev`.\r\n   *\r\n   * @param ev Name of the event\r\n   * @param listener Callback function\r\n   */\n  on(ev, listener) {\n    return super.on(ev, listener);\n  }\n  /**\r\n   * Adds a one-time `listener` function as an event listener for `ev`.\r\n   *\r\n   * @param ev Name of the event\r\n   * @param listener Callback function\r\n   */\n\n\n  once(ev, listener) {\n    return super.once(ev, listener);\n  }\n  /**\r\n   * Emits an event.\r\n   *\r\n   * @param ev Name of the event\r\n   * @param args Values to send to listeners of this event\r\n   */\n\n\n  emit(ev) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return super.emit(ev, ...args);\n  }\n  /**\r\n   * Emits a reserved event.\r\n   *\r\n   * This method is `protected`, so that only a class extending\r\n   * `StrictEventEmitter` can emit its own reserved events.\r\n   *\r\n   * @param ev Reserved event name\r\n   * @param args Arguments to emit along with the event\r\n   */\n\n\n  emitReserved(ev) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    return super.emit(ev, ...args);\n  }\n  /**\r\n   * Emits an event.\r\n   *\r\n   * This method is `protected`, so that only a class extending\r\n   * `StrictEventEmitter` can get around the strict typing. This is useful for\r\n   * calling `emit.apply`, which can be called as `emitUntyped.apply`.\r\n   *\r\n   * @param ev Event name\r\n   * @param args Arguments to emit along with the event\r\n   */\n\n\n  emitUntyped(ev) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n\n    return super.emit(ev, ...args);\n  }\n  /**\r\n   * Returns the listeners listening to an event.\r\n   *\r\n   * @param event Event name\r\n   * @returns Array of listeners subscribed to `event`\r\n   */\n\n\n  listeners(event) {\n    return super.listeners(event);\n  }\n\n}\n\nexports.StrictEventEmitter = StrictEventEmitter;","map":{"version":3,"sources":["C:/Users/gabe/Desktop/Pomo/Team5/client/node_modules/socket.io/dist/typed-events.js"],"names":["Object","defineProperty","exports","value","StrictEventEmitter","events_1","require","EventEmitter","on","ev","listener","once","emit","args","emitReserved","emitUntyped","listeners","event"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,kBAAR,GAA6B,KAAK,CAAlC;;AACA,MAAMC,QAAQ,GAAGC,OAAO,CAAC,QAAD,CAAxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMF,kBAAN,SAAiCC,QAAQ,CAACE,YAA1C,CAAuD;AACnD;AACJ;AACA;AACA;AACA;AACA;AACIC,EAAAA,EAAE,CAACC,EAAD,EAAKC,QAAL,EAAe;AACb,WAAO,MAAMF,EAAN,CAASC,EAAT,EAAaC,QAAb,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,IAAI,CAACF,EAAD,EAAKC,QAAL,EAAe;AACf,WAAO,MAAMC,IAAN,CAAWF,EAAX,EAAeC,QAAf,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACIE,EAAAA,IAAI,CAACH,EAAD,EAAc;AAAA,sCAANI,IAAM;AAANA,MAAAA,IAAM;AAAA;;AACd,WAAO,MAAMD,IAAN,CAAWH,EAAX,EAAe,GAAGI,IAAlB,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,YAAY,CAACL,EAAD,EAAc;AAAA,uCAANI,IAAM;AAANA,MAAAA,IAAM;AAAA;;AACtB,WAAO,MAAMD,IAAN,CAAWH,EAAX,EAAe,GAAGI,IAAlB,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIE,EAAAA,WAAW,CAACN,EAAD,EAAc;AAAA,uCAANI,IAAM;AAANA,MAAAA,IAAM;AAAA;;AACrB,WAAO,MAAMD,IAAN,CAAWH,EAAX,EAAe,GAAGI,IAAlB,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACIG,EAAAA,SAAS,CAACC,KAAD,EAAQ;AACb,WAAO,MAAMD,SAAN,CAAgBC,KAAhB,CAAP;AACH;;AA7DkD;;AA+DvDf,OAAO,CAACE,kBAAR,GAA6BA,kBAA7B","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.StrictEventEmitter = void 0;\r\nconst events_1 = require(\"events\");\r\n/**\r\n * Strictly typed version of an `EventEmitter`. A `TypedEventEmitter` takes type\r\n * parameters for mappings of event names to event data types, and strictly\r\n * types method calls to the `EventEmitter` according to these event maps.\r\n *\r\n * @typeParam ListenEvents - `EventsMap` of user-defined events that can be\r\n * listened to with `on` or `once`\r\n * @typeParam EmitEvents - `EventsMap` of user-defined events that can be\r\n * emitted with `emit`\r\n * @typeParam ReservedEvents - `EventsMap` of reserved events, that can be\r\n * emitted by socket.io with `emitReserved`, and can be listened to with\r\n * `listen`.\r\n */\r\nclass StrictEventEmitter extends events_1.EventEmitter {\r\n    /**\r\n     * Adds the `listener` function as an event listener for `ev`.\r\n     *\r\n     * @param ev Name of the event\r\n     * @param listener Callback function\r\n     */\r\n    on(ev, listener) {\r\n        return super.on(ev, listener);\r\n    }\r\n    /**\r\n     * Adds a one-time `listener` function as an event listener for `ev`.\r\n     *\r\n     * @param ev Name of the event\r\n     * @param listener Callback function\r\n     */\r\n    once(ev, listener) {\r\n        return super.once(ev, listener);\r\n    }\r\n    /**\r\n     * Emits an event.\r\n     *\r\n     * @param ev Name of the event\r\n     * @param args Values to send to listeners of this event\r\n     */\r\n    emit(ev, ...args) {\r\n        return super.emit(ev, ...args);\r\n    }\r\n    /**\r\n     * Emits a reserved event.\r\n     *\r\n     * This method is `protected`, so that only a class extending\r\n     * `StrictEventEmitter` can emit its own reserved events.\r\n     *\r\n     * @param ev Reserved event name\r\n     * @param args Arguments to emit along with the event\r\n     */\r\n    emitReserved(ev, ...args) {\r\n        return super.emit(ev, ...args);\r\n    }\r\n    /**\r\n     * Emits an event.\r\n     *\r\n     * This method is `protected`, so that only a class extending\r\n     * `StrictEventEmitter` can get around the strict typing. This is useful for\r\n     * calling `emit.apply`, which can be called as `emitUntyped.apply`.\r\n     *\r\n     * @param ev Event name\r\n     * @param args Arguments to emit along with the event\r\n     */\r\n    emitUntyped(ev, ...args) {\r\n        return super.emit(ev, ...args);\r\n    }\r\n    /**\r\n     * Returns the listeners listening to an event.\r\n     *\r\n     * @param event Event name\r\n     * @returns Array of listeners subscribed to `event`\r\n     */\r\n    listeners(event) {\r\n        return super.listeners(event);\r\n    }\r\n}\r\nexports.StrictEventEmitter = StrictEventEmitter;\r\n"]},"metadata":{},"sourceType":"script"}