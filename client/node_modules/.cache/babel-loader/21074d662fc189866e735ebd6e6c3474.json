{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Polling = void 0;\n\nconst transport_1 = require(\"../transport\");\n\nconst zlib_1 = require(\"zlib\");\n\nconst accepts = require(\"accepts\");\n\nconst debug_1 = require(\"debug\");\n\nconst debug = (0, debug_1.default)(\"engine:polling\");\nconst compressionMethods = {\n  gzip: zlib_1.createGzip,\n  deflate: zlib_1.createDeflate\n};\n\nclass Polling extends transport_1.Transport {\n  /**\r\n   * HTTP polling constructor.\r\n   *\r\n   * @api public.\r\n   */\n  constructor(req) {\n    super(req);\n    this.closeTimeout = 30 * 1000;\n  }\n  /**\r\n   * Transport name\r\n   *\r\n   * @api public\r\n   */\n\n\n  get name() {\n    return \"polling\";\n  }\n\n  get supportsFraming() {\n    return false;\n  }\n  /**\r\n   * Overrides onRequest.\r\n   *\r\n   * @param req\r\n   *\r\n   * @api private\r\n   */\n\n\n  onRequest(req) {\n    const res = req.res;\n\n    if (req.getMethod() === \"get\") {\n      this.onPollRequest(req, res);\n    } else if (req.getMethod() === \"post\") {\n      this.onDataRequest(req, res);\n    } else {\n      res.writeStatus(\"500 Internal Server Error\");\n      res.end();\n    }\n  }\n  /**\r\n   * The client sends a request awaiting for us to send data.\r\n   *\r\n   * @api private\r\n   */\n\n\n  onPollRequest(req, res) {\n    if (this.req) {\n      debug(\"request overlap\"); // assert: this.res, '.req and .res should be (un)set together'\n\n      this.onError(\"overlap from client\");\n      res.writeStatus(\"500 Internal Server Error\");\n      res.end();\n      return;\n    }\n\n    debug(\"setting request\");\n    this.req = req;\n    this.res = res;\n\n    const onClose = () => {\n      this.writable = false;\n      this.onError(\"poll connection closed prematurely\");\n    };\n\n    const cleanup = () => {\n      this.req = this.res = null;\n    };\n\n    req.cleanup = cleanup;\n    res.onAborted(onClose);\n    this.writable = true;\n    this.emit(\"drain\"); // if we're still writable but had a pending close, trigger an empty send\n\n    if (this.writable && this.shouldClose) {\n      debug(\"triggering empty send to append close packet\");\n      this.send([{\n        type: \"noop\"\n      }]);\n    }\n  }\n  /**\r\n   * The client sends a request with data.\r\n   *\r\n   * @api private\r\n   */\n\n\n  onDataRequest(req, res) {\n    if (this.dataReq) {\n      // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'\n      this.onError(\"data request overlap from client\");\n      res.writeStatus(\"500 Internal Server Error\");\n      res.end();\n      return;\n    }\n\n    const expectedContentLength = Number(req.headers[\"content-length\"]);\n\n    if (!expectedContentLength) {\n      this.onError(\"content-length header required\");\n      res.writeStatus(\"411 Length Required\").end();\n      return;\n    }\n\n    if (expectedContentLength > this.maxHttpBufferSize) {\n      this.onError(\"payload too large\");\n      res.writeStatus(\"413 Payload Too Large\").end();\n      return;\n    }\n\n    const isBinary = \"application/octet-stream\" === req.headers[\"content-type\"];\n\n    if (isBinary && this.protocol === 4) {\n      return this.onError(\"invalid content\");\n    }\n\n    this.dataReq = req;\n    this.dataRes = res;\n    let buffer;\n    let offset = 0;\n    const headers = {\n      // text/html is required instead of text/plain to avoid an\n      // unwanted download dialog on certain user-agents (GH-43)\n      \"Content-Type\": \"text/html\"\n    };\n    this.headers(req, headers);\n\n    for (let key in headers) {\n      res.writeHeader(key, String(headers[key]));\n    }\n\n    const onEnd = buffer => {\n      this.onData(buffer.toString());\n      this.onDataRequestCleanup();\n      res.end(\"ok\");\n    };\n\n    res.onAborted(() => {\n      this.onDataRequestCleanup();\n      this.onError(\"data request connection closed prematurely\");\n    });\n    res.onData((arrayBuffer, isLast) => {\n      const totalLength = offset + arrayBuffer.byteLength;\n\n      if (totalLength > expectedContentLength) {\n        this.onError(\"content-length mismatch\");\n        res.close(); // calls onAborted\n\n        return;\n      }\n\n      if (!buffer) {\n        if (isLast) {\n          onEnd(Buffer.from(arrayBuffer));\n          return;\n        }\n\n        buffer = Buffer.allocUnsafe(expectedContentLength);\n      }\n\n      Buffer.from(arrayBuffer).copy(buffer, offset);\n\n      if (isLast) {\n        if (totalLength != expectedContentLength) {\n          this.onError(\"content-length mismatch\");\n          res.writeStatus(\"400 Content-Length Mismatch\").end();\n          this.onDataRequestCleanup();\n          return;\n        }\n\n        onEnd(buffer);\n        return;\n      }\n\n      offset = totalLength;\n    });\n  }\n  /**\r\n   * Cleanup request.\r\n   *\r\n   * @api private\r\n   */\n\n\n  onDataRequestCleanup() {\n    this.dataReq = this.dataRes = null;\n  }\n  /**\r\n   * Processes the incoming data payload.\r\n   *\r\n   * @param {String} encoded payload\r\n   * @api private\r\n   */\n\n\n  onData(data) {\n    debug('received \"%s\"', data);\n\n    const callback = packet => {\n      if (\"close\" === packet.type) {\n        debug(\"got xhr close packet\");\n        this.onClose();\n        return false;\n      }\n\n      this.onPacket(packet);\n    };\n\n    if (this.protocol === 3) {\n      this.parser.decodePayload(data, callback);\n    } else {\n      this.parser.decodePayload(data).forEach(callback);\n    }\n  }\n  /**\r\n   * Overrides onClose.\r\n   *\r\n   * @api private\r\n   */\n\n\n  onClose() {\n    if (this.writable) {\n      // close pending poll request\n      this.send([{\n        type: \"noop\"\n      }]);\n    }\n\n    super.onClose();\n  }\n  /**\r\n   * Writes a packet payload.\r\n   *\r\n   * @param {Object} packet\r\n   * @api private\r\n   */\n\n\n  send(packets) {\n    this.writable = false;\n\n    if (this.shouldClose) {\n      debug(\"appending close packet to payload\");\n      packets.push({\n        type: \"close\"\n      });\n      this.shouldClose();\n      this.shouldClose = null;\n    }\n\n    const doWrite = data => {\n      const compress = packets.some(packet => {\n        return packet.options && packet.options.compress;\n      });\n      this.write(data, {\n        compress\n      });\n    };\n\n    if (this.protocol === 3) {\n      this.parser.encodePayload(packets, this.supportsBinary, doWrite);\n    } else {\n      this.parser.encodePayload(packets, doWrite);\n    }\n  }\n  /**\r\n   * Writes data as response to poll request.\r\n   *\r\n   * @param {String} data\r\n   * @param {Object} options\r\n   * @api private\r\n   */\n\n\n  write(data, options) {\n    debug('writing \"%s\"', data);\n    this.doWrite(data, options, () => {\n      this.req.cleanup();\n    });\n  }\n  /**\r\n   * Performs the write.\r\n   *\r\n   * @api private\r\n   */\n\n\n  doWrite(data, options, callback) {\n    // explicit UTF-8 is required for pages not served under utf\n    const isString = typeof data === \"string\";\n    const contentType = isString ? \"text/plain; charset=UTF-8\" : \"application/octet-stream\";\n    const headers = {\n      \"Content-Type\": contentType\n    };\n\n    const respond = data => {\n      this.headers(this.req, headers);\n      Object.keys(headers).forEach(key => {\n        this.res.writeHeader(key, String(headers[key]));\n      });\n      this.res.end(data);\n      callback();\n    };\n\n    if (!this.httpCompression || !options.compress) {\n      respond(data);\n      return;\n    }\n\n    const len = isString ? Buffer.byteLength(data) : data.length;\n\n    if (len < this.httpCompression.threshold) {\n      respond(data);\n      return;\n    }\n\n    const encoding = accepts(this.req).encodings([\"gzip\", \"deflate\"]);\n\n    if (!encoding) {\n      respond(data);\n      return;\n    }\n\n    this.compress(data, encoding, (err, data) => {\n      if (err) {\n        this.res.writeStatus(\"500 Internal Server Error\");\n        this.res.end();\n        callback(err);\n        return;\n      }\n\n      headers[\"Content-Encoding\"] = encoding;\n      respond(data);\n    });\n  }\n  /**\r\n   * Compresses data.\r\n   *\r\n   * @api private\r\n   */\n\n\n  compress(data, encoding, callback) {\n    debug(\"compressing\");\n    const buffers = [];\n    let nread = 0;\n    compressionMethods[encoding](this.httpCompression).on(\"error\", callback).on(\"data\", function (chunk) {\n      buffers.push(chunk);\n      nread += chunk.length;\n    }).on(\"end\", function () {\n      callback(null, Buffer.concat(buffers, nread));\n    }).end(data);\n  }\n  /**\r\n   * Closes the transport.\r\n   *\r\n   * @api private\r\n   */\n\n\n  doClose(fn) {\n    debug(\"closing\");\n    let closeTimeoutTimer;\n\n    const onClose = () => {\n      clearTimeout(closeTimeoutTimer);\n      fn();\n      this.onClose();\n    };\n\n    if (this.writable) {\n      debug(\"transport writable - closing right away\");\n      this.send([{\n        type: \"close\"\n      }]);\n      onClose();\n    } else if (this.discarded) {\n      debug(\"transport discarded - closing right away\");\n      onClose();\n    } else {\n      debug(\"transport not writable - buffering orderly close\");\n      this.shouldClose = onClose;\n      closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);\n    }\n  }\n  /**\r\n   * Returns headers for a response.\r\n   *\r\n   * @param req - request\r\n   * @param {Object} extra headers\r\n   * @api private\r\n   */\n\n\n  headers(req, headers) {\n    headers = headers || {}; // prevent XSS warnings on IE\n    // https://github.com/LearnBoost/socket.io/pull/1333\n\n    const ua = req.headers[\"user-agent\"];\n\n    if (ua && (~ua.indexOf(\";MSIE\") || ~ua.indexOf(\"Trident/\"))) {\n      headers[\"X-XSS-Protection\"] = \"0\";\n    }\n\n    this.emit(\"headers\", headers, req);\n    return headers;\n  }\n\n}\n\nexports.Polling = Polling;","map":{"version":3,"sources":["C:/Users/gabe/Desktop/Pomo/Team5/client/node_modules/engine.io/build/transports-uws/polling.js"],"names":["Object","defineProperty","exports","value","Polling","transport_1","require","zlib_1","accepts","debug_1","debug","default","compressionMethods","gzip","createGzip","deflate","createDeflate","Transport","constructor","req","closeTimeout","name","supportsFraming","onRequest","res","getMethod","onPollRequest","onDataRequest","writeStatus","end","onError","onClose","writable","cleanup","onAborted","emit","shouldClose","send","type","dataReq","expectedContentLength","Number","headers","maxHttpBufferSize","isBinary","protocol","dataRes","buffer","offset","key","writeHeader","String","onEnd","onData","toString","onDataRequestCleanup","arrayBuffer","isLast","totalLength","byteLength","close","Buffer","from","allocUnsafe","copy","data","callback","packet","onPacket","parser","decodePayload","forEach","packets","push","doWrite","compress","some","options","write","encodePayload","supportsBinary","isString","contentType","respond","keys","httpCompression","len","length","threshold","encoding","encodings","err","buffers","nread","on","chunk","concat","doClose","fn","closeTimeoutTimer","clearTimeout","discarded","setTimeout","ua","indexOf"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Polling = void 0;\r\nconst transport_1 = require(\"../transport\");\r\nconst zlib_1 = require(\"zlib\");\r\nconst accepts = require(\"accepts\");\r\nconst debug_1 = require(\"debug\");\r\nconst debug = (0, debug_1.default)(\"engine:polling\");\r\nconst compressionMethods = {\r\n    gzip: zlib_1.createGzip,\r\n    deflate: zlib_1.createDeflate\r\n};\r\nclass Polling extends transport_1.Transport {\r\n    /**\r\n     * HTTP polling constructor.\r\n     *\r\n     * @api public.\r\n     */\r\n    constructor(req) {\r\n        super(req);\r\n        this.closeTimeout = 30 * 1000;\r\n    }\r\n    /**\r\n     * Transport name\r\n     *\r\n     * @api public\r\n     */\r\n    get name() {\r\n        return \"polling\";\r\n    }\r\n    get supportsFraming() {\r\n        return false;\r\n    }\r\n    /**\r\n     * Overrides onRequest.\r\n     *\r\n     * @param req\r\n     *\r\n     * @api private\r\n     */\r\n    onRequest(req) {\r\n        const res = req.res;\r\n        if (req.getMethod() === \"get\") {\r\n            this.onPollRequest(req, res);\r\n        }\r\n        else if (req.getMethod() === \"post\") {\r\n            this.onDataRequest(req, res);\r\n        }\r\n        else {\r\n            res.writeStatus(\"500 Internal Server Error\");\r\n            res.end();\r\n        }\r\n    }\r\n    /**\r\n     * The client sends a request awaiting for us to send data.\r\n     *\r\n     * @api private\r\n     */\r\n    onPollRequest(req, res) {\r\n        if (this.req) {\r\n            debug(\"request overlap\");\r\n            // assert: this.res, '.req and .res should be (un)set together'\r\n            this.onError(\"overlap from client\");\r\n            res.writeStatus(\"500 Internal Server Error\");\r\n            res.end();\r\n            return;\r\n        }\r\n        debug(\"setting request\");\r\n        this.req = req;\r\n        this.res = res;\r\n        const onClose = () => {\r\n            this.writable = false;\r\n            this.onError(\"poll connection closed prematurely\");\r\n        };\r\n        const cleanup = () => {\r\n            this.req = this.res = null;\r\n        };\r\n        req.cleanup = cleanup;\r\n        res.onAborted(onClose);\r\n        this.writable = true;\r\n        this.emit(\"drain\");\r\n        // if we're still writable but had a pending close, trigger an empty send\r\n        if (this.writable && this.shouldClose) {\r\n            debug(\"triggering empty send to append close packet\");\r\n            this.send([{ type: \"noop\" }]);\r\n        }\r\n    }\r\n    /**\r\n     * The client sends a request with data.\r\n     *\r\n     * @api private\r\n     */\r\n    onDataRequest(req, res) {\r\n        if (this.dataReq) {\r\n            // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'\r\n            this.onError(\"data request overlap from client\");\r\n            res.writeStatus(\"500 Internal Server Error\");\r\n            res.end();\r\n            return;\r\n        }\r\n        const expectedContentLength = Number(req.headers[\"content-length\"]);\r\n        if (!expectedContentLength) {\r\n            this.onError(\"content-length header required\");\r\n            res.writeStatus(\"411 Length Required\").end();\r\n            return;\r\n        }\r\n        if (expectedContentLength > this.maxHttpBufferSize) {\r\n            this.onError(\"payload too large\");\r\n            res.writeStatus(\"413 Payload Too Large\").end();\r\n            return;\r\n        }\r\n        const isBinary = \"application/octet-stream\" === req.headers[\"content-type\"];\r\n        if (isBinary && this.protocol === 4) {\r\n            return this.onError(\"invalid content\");\r\n        }\r\n        this.dataReq = req;\r\n        this.dataRes = res;\r\n        let buffer;\r\n        let offset = 0;\r\n        const headers = {\r\n            // text/html is required instead of text/plain to avoid an\r\n            // unwanted download dialog on certain user-agents (GH-43)\r\n            \"Content-Type\": \"text/html\"\r\n        };\r\n        this.headers(req, headers);\r\n        for (let key in headers) {\r\n            res.writeHeader(key, String(headers[key]));\r\n        }\r\n        const onEnd = buffer => {\r\n            this.onData(buffer.toString());\r\n            this.onDataRequestCleanup();\r\n            res.end(\"ok\");\r\n        };\r\n        res.onAborted(() => {\r\n            this.onDataRequestCleanup();\r\n            this.onError(\"data request connection closed prematurely\");\r\n        });\r\n        res.onData((arrayBuffer, isLast) => {\r\n            const totalLength = offset + arrayBuffer.byteLength;\r\n            if (totalLength > expectedContentLength) {\r\n                this.onError(\"content-length mismatch\");\r\n                res.close(); // calls onAborted\r\n                return;\r\n            }\r\n            if (!buffer) {\r\n                if (isLast) {\r\n                    onEnd(Buffer.from(arrayBuffer));\r\n                    return;\r\n                }\r\n                buffer = Buffer.allocUnsafe(expectedContentLength);\r\n            }\r\n            Buffer.from(arrayBuffer).copy(buffer, offset);\r\n            if (isLast) {\r\n                if (totalLength != expectedContentLength) {\r\n                    this.onError(\"content-length mismatch\");\r\n                    res.writeStatus(\"400 Content-Length Mismatch\").end();\r\n                    this.onDataRequestCleanup();\r\n                    return;\r\n                }\r\n                onEnd(buffer);\r\n                return;\r\n            }\r\n            offset = totalLength;\r\n        });\r\n    }\r\n    /**\r\n     * Cleanup request.\r\n     *\r\n     * @api private\r\n     */\r\n    onDataRequestCleanup() {\r\n        this.dataReq = this.dataRes = null;\r\n    }\r\n    /**\r\n     * Processes the incoming data payload.\r\n     *\r\n     * @param {String} encoded payload\r\n     * @api private\r\n     */\r\n    onData(data) {\r\n        debug('received \"%s\"', data);\r\n        const callback = packet => {\r\n            if (\"close\" === packet.type) {\r\n                debug(\"got xhr close packet\");\r\n                this.onClose();\r\n                return false;\r\n            }\r\n            this.onPacket(packet);\r\n        };\r\n        if (this.protocol === 3) {\r\n            this.parser.decodePayload(data, callback);\r\n        }\r\n        else {\r\n            this.parser.decodePayload(data).forEach(callback);\r\n        }\r\n    }\r\n    /**\r\n     * Overrides onClose.\r\n     *\r\n     * @api private\r\n     */\r\n    onClose() {\r\n        if (this.writable) {\r\n            // close pending poll request\r\n            this.send([{ type: \"noop\" }]);\r\n        }\r\n        super.onClose();\r\n    }\r\n    /**\r\n     * Writes a packet payload.\r\n     *\r\n     * @param {Object} packet\r\n     * @api private\r\n     */\r\n    send(packets) {\r\n        this.writable = false;\r\n        if (this.shouldClose) {\r\n            debug(\"appending close packet to payload\");\r\n            packets.push({ type: \"close\" });\r\n            this.shouldClose();\r\n            this.shouldClose = null;\r\n        }\r\n        const doWrite = data => {\r\n            const compress = packets.some(packet => {\r\n                return packet.options && packet.options.compress;\r\n            });\r\n            this.write(data, { compress });\r\n        };\r\n        if (this.protocol === 3) {\r\n            this.parser.encodePayload(packets, this.supportsBinary, doWrite);\r\n        }\r\n        else {\r\n            this.parser.encodePayload(packets, doWrite);\r\n        }\r\n    }\r\n    /**\r\n     * Writes data as response to poll request.\r\n     *\r\n     * @param {String} data\r\n     * @param {Object} options\r\n     * @api private\r\n     */\r\n    write(data, options) {\r\n        debug('writing \"%s\"', data);\r\n        this.doWrite(data, options, () => {\r\n            this.req.cleanup();\r\n        });\r\n    }\r\n    /**\r\n     * Performs the write.\r\n     *\r\n     * @api private\r\n     */\r\n    doWrite(data, options, callback) {\r\n        // explicit UTF-8 is required for pages not served under utf\r\n        const isString = typeof data === \"string\";\r\n        const contentType = isString\r\n            ? \"text/plain; charset=UTF-8\"\r\n            : \"application/octet-stream\";\r\n        const headers = {\r\n            \"Content-Type\": contentType\r\n        };\r\n        const respond = data => {\r\n            this.headers(this.req, headers);\r\n            Object.keys(headers).forEach(key => {\r\n                this.res.writeHeader(key, String(headers[key]));\r\n            });\r\n            this.res.end(data);\r\n            callback();\r\n        };\r\n        if (!this.httpCompression || !options.compress) {\r\n            respond(data);\r\n            return;\r\n        }\r\n        const len = isString ? Buffer.byteLength(data) : data.length;\r\n        if (len < this.httpCompression.threshold) {\r\n            respond(data);\r\n            return;\r\n        }\r\n        const encoding = accepts(this.req).encodings([\"gzip\", \"deflate\"]);\r\n        if (!encoding) {\r\n            respond(data);\r\n            return;\r\n        }\r\n        this.compress(data, encoding, (err, data) => {\r\n            if (err) {\r\n                this.res.writeStatus(\"500 Internal Server Error\");\r\n                this.res.end();\r\n                callback(err);\r\n                return;\r\n            }\r\n            headers[\"Content-Encoding\"] = encoding;\r\n            respond(data);\r\n        });\r\n    }\r\n    /**\r\n     * Compresses data.\r\n     *\r\n     * @api private\r\n     */\r\n    compress(data, encoding, callback) {\r\n        debug(\"compressing\");\r\n        const buffers = [];\r\n        let nread = 0;\r\n        compressionMethods[encoding](this.httpCompression)\r\n            .on(\"error\", callback)\r\n            .on(\"data\", function (chunk) {\r\n            buffers.push(chunk);\r\n            nread += chunk.length;\r\n        })\r\n            .on(\"end\", function () {\r\n            callback(null, Buffer.concat(buffers, nread));\r\n        })\r\n            .end(data);\r\n    }\r\n    /**\r\n     * Closes the transport.\r\n     *\r\n     * @api private\r\n     */\r\n    doClose(fn) {\r\n        debug(\"closing\");\r\n        let closeTimeoutTimer;\r\n        const onClose = () => {\r\n            clearTimeout(closeTimeoutTimer);\r\n            fn();\r\n            this.onClose();\r\n        };\r\n        if (this.writable) {\r\n            debug(\"transport writable - closing right away\");\r\n            this.send([{ type: \"close\" }]);\r\n            onClose();\r\n        }\r\n        else if (this.discarded) {\r\n            debug(\"transport discarded - closing right away\");\r\n            onClose();\r\n        }\r\n        else {\r\n            debug(\"transport not writable - buffering orderly close\");\r\n            this.shouldClose = onClose;\r\n            closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);\r\n        }\r\n    }\r\n    /**\r\n     * Returns headers for a response.\r\n     *\r\n     * @param req - request\r\n     * @param {Object} extra headers\r\n     * @api private\r\n     */\r\n    headers(req, headers) {\r\n        headers = headers || {};\r\n        // prevent XSS warnings on IE\r\n        // https://github.com/LearnBoost/socket.io/pull/1333\r\n        const ua = req.headers[\"user-agent\"];\r\n        if (ua && (~ua.indexOf(\";MSIE\") || ~ua.indexOf(\"Trident/\"))) {\r\n            headers[\"X-XSS-Protection\"] = \"0\";\r\n        }\r\n        this.emit(\"headers\", headers, req);\r\n        return headers;\r\n    }\r\n}\r\nexports.Polling = Polling;\r\n"]},"metadata":{},"sourceType":"script"}