{"ast":null,"code":"\"use strict\"; // imported from https://github.com/socketio/engine.io-parser/tree/2.2.x\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodePayloadAsBinary = exports.encodePayloadAsBinary = exports.decodePayload = exports.encodePayload = exports.decodeBase64Packet = exports.decodePacket = exports.encodeBase64Packet = exports.encodePacket = exports.packets = exports.protocol = void 0;\n/**\r\n * Module dependencies.\r\n */\n\nvar utf8 = require('./utf8');\n/**\r\n * Current protocol version.\r\n */\n\n\nexports.protocol = 3;\n\nconst hasBinary = packets => {\n  for (const packet of packets) {\n    if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\r\n * Packet types.\r\n */\n\n\nexports.packets = {\n  open: 0 // non-ws\n  ,\n  close: 1 // non-ws\n  ,\n  ping: 2,\n  pong: 3,\n  message: 4,\n  upgrade: 5,\n  noop: 6\n};\nvar packetslist = Object.keys(exports.packets);\n/**\r\n * Premade error packet.\r\n */\n\nvar err = {\n  type: 'error',\n  data: 'parser error'\n};\nconst EMPTY_BUFFER = Buffer.concat([]);\n/**\r\n * Encodes a packet.\r\n *\r\n *     <packet type id> [ <data> ]\r\n *\r\n * Example:\r\n *\r\n *     5hello world\r\n *     3\r\n *     4\r\n *\r\n * Binary is encoded in an identical principle\r\n *\r\n * @api private\r\n */\n\nfunction encodePacket(packet, supportsBinary, utf8encode, callback) {\n  if (typeof supportsBinary === 'function') {\n    callback = supportsBinary;\n    supportsBinary = null;\n  }\n\n  if (typeof utf8encode === 'function') {\n    callback = utf8encode;\n    utf8encode = null;\n  }\n\n  if (Buffer.isBuffer(packet.data)) {\n    return encodeBuffer(packet, supportsBinary, callback);\n  } else if (packet.data && (packet.data.buffer || packet.data) instanceof ArrayBuffer) {\n    return encodeBuffer({\n      type: packet.type,\n      data: arrayBufferToBuffer(packet.data)\n    }, supportsBinary, callback);\n  } // Sending data as a utf-8 string\n\n\n  var encoded = exports.packets[packet.type]; // data fragment is optional\n\n  if (undefined !== packet.data) {\n    encoded += utf8encode ? utf8.encode(String(packet.data), {\n      strict: false\n    }) : String(packet.data);\n  }\n\n  return callback('' + encoded);\n}\n\nexports.encodePacket = encodePacket;\n;\n/**\r\n * Encode Buffer data\r\n */\n\nfunction encodeBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return encodeBase64Packet(packet, callback);\n  }\n\n  var data = packet.data;\n  var typeBuffer = Buffer.allocUnsafe(1);\n  typeBuffer[0] = exports.packets[packet.type];\n  return callback(Buffer.concat([typeBuffer, data]));\n}\n/**\r\n * Encodes a packet with binary data in a base64 string\r\n *\r\n * @param {Object} packet, has `type` and `data`\r\n * @return {String} base64 encoded message\r\n */\n\n\nfunction encodeBase64Packet(packet, callback) {\n  var data = Buffer.isBuffer(packet.data) ? packet.data : arrayBufferToBuffer(packet.data);\n  var message = 'b' + exports.packets[packet.type];\n  message += data.toString('base64');\n  return callback(message);\n}\n\nexports.encodeBase64Packet = encodeBase64Packet;\n;\n/**\r\n * Decodes a packet. Data also available as an ArrayBuffer if requested.\r\n *\r\n * @return {Object} with `type` and `data` (if any)\r\n * @api private\r\n */\n\nfunction decodePacket(data, binaryType, utf8decode) {\n  if (data === undefined) {\n    return err;\n  }\n\n  var type; // String data\n\n  if (typeof data === 'string') {\n    type = data.charAt(0);\n\n    if (type === 'b') {\n      return decodeBase64Packet(data.substr(1), binaryType);\n    }\n\n    if (utf8decode) {\n      data = tryDecode(data);\n\n      if (data === false) {\n        return err;\n      }\n    }\n\n    if (Number(type) != type || !packetslist[type]) {\n      return err;\n    }\n\n    if (data.length > 1) {\n      return {\n        type: packetslist[type],\n        data: data.substring(1)\n      };\n    } else {\n      return {\n        type: packetslist[type]\n      };\n    }\n  } // Binary data\n\n\n  if (binaryType === 'arraybuffer') {\n    // wrap Buffer/ArrayBuffer data into an Uint8Array\n    var intArray = new Uint8Array(data);\n    type = intArray[0];\n    return {\n      type: packetslist[type],\n      data: intArray.buffer.slice(1)\n    };\n  }\n\n  if (data instanceof ArrayBuffer) {\n    data = arrayBufferToBuffer(data);\n  }\n\n  type = data[0];\n  return {\n    type: packetslist[type],\n    data: data.slice(1)\n  };\n}\n\nexports.decodePacket = decodePacket;\n;\n\nfunction tryDecode(data) {\n  try {\n    data = utf8.decode(data, {\n      strict: false\n    });\n  } catch (e) {\n    return false;\n  }\n\n  return data;\n}\n/**\r\n * Decodes a packet encoded in a base64 string.\r\n *\r\n * @param {String} base64 encoded message\r\n * @return {Object} with `type` and `data` (if any)\r\n */\n\n\nfunction decodeBase64Packet(msg, binaryType) {\n  var type = packetslist[msg.charAt(0)];\n  var data = Buffer.from(msg.substr(1), 'base64');\n\n  if (binaryType === 'arraybuffer') {\n    var abv = new Uint8Array(data.length);\n\n    for (var i = 0; i < abv.length; i++) {\n      abv[i] = data[i];\n    } // @ts-ignore\n\n\n    data = abv.buffer;\n  }\n\n  return {\n    type: type,\n    data: data\n  };\n}\n\nexports.decodeBase64Packet = decodeBase64Packet;\n;\n/**\r\n * Encodes multiple messages (payload).\r\n *\r\n *     <length>:data\r\n *\r\n * Example:\r\n *\r\n *     11:hello world2:hi\r\n *\r\n * If any contents are binary, they will be encoded as base64 strings. Base64\r\n * encoded strings are marked with a b before the length specifier\r\n *\r\n * @param {Array} packets\r\n * @api private\r\n */\n\nfunction encodePayload(packets, supportsBinary, callback) {\n  if (typeof supportsBinary === 'function') {\n    callback = supportsBinary;\n    supportsBinary = null;\n  }\n\n  if (supportsBinary && hasBinary(packets)) {\n    return encodePayloadAsBinary(packets, callback);\n  }\n\n  if (!packets.length) {\n    return callback('0:');\n  }\n\n  function encodeOne(packet, doneCallback) {\n    encodePacket(packet, supportsBinary, false, function (message) {\n      doneCallback(null, setLengthHeader(message));\n    });\n  }\n\n  map(packets, encodeOne, function (err, results) {\n    return callback(results.join(''));\n  });\n}\n\nexports.encodePayload = encodePayload;\n;\n\nfunction setLengthHeader(message) {\n  return message.length + ':' + message;\n}\n/**\r\n * Async array map using after\r\n */\n\n\nfunction map(ary, each, done) {\n  const results = new Array(ary.length);\n  let count = 0;\n\n  for (let i = 0; i < ary.length; i++) {\n    each(ary[i], (error, msg) => {\n      results[i] = msg;\n\n      if (++count === ary.length) {\n        done(null, results);\n      }\n    });\n  }\n}\n/*\r\n * Decodes data when a payload is maybe expected. Possible binary contents are\r\n * decoded from their base64 representation\r\n *\r\n * @param {String} data, callback method\r\n * @api public\r\n */\n\n\nfunction decodePayload(data, binaryType, callback) {\n  if (typeof data !== 'string') {\n    return decodePayloadAsBinary(data, binaryType, callback);\n  }\n\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  if (data === '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n  var length = '',\n      n,\n      msg,\n      packet;\n\n  for (var i = 0, l = data.length; i < l; i++) {\n    var chr = data.charAt(i);\n\n    if (chr !== ':') {\n      length += chr;\n      continue;\n    } // @ts-ignore\n\n\n    if (length === '' || length != (n = Number(length))) {\n      // parser error - ignoring payload\n      return callback(err, 0, 1);\n    }\n\n    msg = data.substr(i + 1, n);\n\n    if (length != msg.length) {\n      // parser error - ignoring payload\n      return callback(err, 0, 1);\n    }\n\n    if (msg.length) {\n      packet = decodePacket(msg, binaryType, false);\n\n      if (err.type === packet.type && err.data === packet.data) {\n        // parser error in individual packet - ignoring payload\n        return callback(err, 0, 1);\n      }\n\n      var more = callback(packet, i + n, l);\n      if (false === more) return;\n    } // advance cursor\n\n\n    i += n;\n    length = '';\n  }\n\n  if (length !== '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n}\n\nexports.decodePayload = decodePayload;\n;\n/**\r\n *\r\n * Converts a buffer to a utf8.js encoded string\r\n *\r\n * @api private\r\n */\n\nfunction bufferToString(buffer) {\n  var str = '';\n\n  for (var i = 0, l = buffer.length; i < l; i++) {\n    str += String.fromCharCode(buffer[i]);\n  }\n\n  return str;\n}\n/**\r\n *\r\n * Converts a utf8.js encoded string to a buffer\r\n *\r\n * @api private\r\n */\n\n\nfunction stringToBuffer(string) {\n  var buf = Buffer.allocUnsafe(string.length);\n\n  for (var i = 0, l = string.length; i < l; i++) {\n    buf.writeUInt8(string.charCodeAt(i), i);\n  }\n\n  return buf;\n}\n/**\r\n *\r\n * Converts an ArrayBuffer to a Buffer\r\n *\r\n * @api private\r\n */\n\n\nfunction arrayBufferToBuffer(data) {\n  // data is either an ArrayBuffer or ArrayBufferView.\n  var length = data.byteLength || data.length;\n  var offset = data.byteOffset || 0;\n  return Buffer.from(data.buffer || data, offset, length);\n}\n/**\r\n * Encodes multiple messages (payload) as binary.\r\n *\r\n * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number\r\n * 255><data>\r\n *\r\n * Example:\r\n * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers\r\n *\r\n * @param {Array} packets\r\n * @return {Buffer} encoded payload\r\n * @api private\r\n */\n\n\nfunction encodePayloadAsBinary(packets, callback) {\n  if (!packets.length) {\n    return callback(EMPTY_BUFFER);\n  }\n\n  map(packets, encodeOneBinaryPacket, function (err, results) {\n    return callback(Buffer.concat(results));\n  });\n}\n\nexports.encodePayloadAsBinary = encodePayloadAsBinary;\n;\n\nfunction encodeOneBinaryPacket(p, doneCallback) {\n  function onBinaryPacketEncode(packet) {\n    var encodingLength = '' + packet.length;\n    var sizeBuffer;\n\n    if (typeof packet === 'string') {\n      sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);\n      sizeBuffer[0] = 0; // is a string (not true binary = 0)\n\n      for (var i = 0; i < encodingLength.length; i++) {\n        sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);\n      }\n\n      sizeBuffer[sizeBuffer.length - 1] = 255;\n      return doneCallback(null, Buffer.concat([sizeBuffer, stringToBuffer(packet)]));\n    }\n\n    sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);\n    sizeBuffer[0] = 1; // is binary (true binary = 1)\n\n    for (var i = 0; i < encodingLength.length; i++) {\n      sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);\n    }\n\n    sizeBuffer[sizeBuffer.length - 1] = 255;\n    doneCallback(null, Buffer.concat([sizeBuffer, packet]));\n  }\n\n  encodePacket(p, true, true, onBinaryPacketEncode);\n}\n/*\r\n * Decodes data when a payload is maybe expected. Strings are decoded by\r\n * interpreting each byte as a key code for entries marked to start with 0. See\r\n * description of encodePayloadAsBinary\r\n\r\n * @param {Buffer} data, callback method\r\n * @api public\r\n */\n\n\nfunction decodePayloadAsBinary(data, binaryType, callback) {\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var bufferTail = data;\n  var buffers = [];\n  var i;\n\n  while (bufferTail.length > 0) {\n    var strLen = '';\n    var isString = bufferTail[0] === 0;\n\n    for (i = 1;; i++) {\n      if (bufferTail[i] === 255) break; // 310 = char length of Number.MAX_VALUE\n\n      if (strLen.length > 310) {\n        return callback(err, 0, 1);\n      }\n\n      strLen += '' + bufferTail[i];\n    }\n\n    bufferTail = bufferTail.slice(strLen.length + 1);\n    var msgLength = parseInt(strLen, 10);\n    var msg = bufferTail.slice(1, msgLength + 1);\n    if (isString) msg = bufferToString(msg);\n    buffers.push(msg);\n    bufferTail = bufferTail.slice(msgLength + 1);\n  }\n\n  var total = buffers.length;\n\n  for (i = 0; i < total; i++) {\n    var buffer = buffers[i];\n    callback(decodePacket(buffer, binaryType, true), i, total);\n  }\n}\n\nexports.decodePayloadAsBinary = decodePayloadAsBinary;\n;","map":{"version":3,"sources":["C:/Users/gabe/Desktop/Pomo/Team5/client/node_modules/engine.io/build/parser-v3/index.js"],"names":["Object","defineProperty","exports","value","decodePayloadAsBinary","encodePayloadAsBinary","decodePayload","encodePayload","decodeBase64Packet","decodePacket","encodeBase64Packet","encodePacket","packets","protocol","utf8","require","hasBinary","packet","data","ArrayBuffer","isView","open","close","ping","pong","message","upgrade","noop","packetslist","keys","err","type","EMPTY_BUFFER","Buffer","concat","supportsBinary","utf8encode","callback","isBuffer","encodeBuffer","buffer","arrayBufferToBuffer","encoded","undefined","encode","String","strict","typeBuffer","allocUnsafe","toString","binaryType","utf8decode","charAt","substr","tryDecode","Number","length","substring","intArray","Uint8Array","slice","decode","e","msg","from","abv","i","encodeOne","doneCallback","setLengthHeader","map","results","join","ary","each","done","Array","count","error","n","l","chr","more","bufferToString","str","fromCharCode","stringToBuffer","string","buf","writeUInt8","charCodeAt","byteLength","offset","byteOffset","encodeOneBinaryPacket","p","onBinaryPacketEncode","encodingLength","sizeBuffer","parseInt","bufferTail","buffers","strLen","isString","msgLength","push","total"],"mappings":"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","sourcesContent":["\"use strict\";\r\n// imported from https://github.com/socketio/engine.io-parser/tree/2.2.x\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.decodePayloadAsBinary = exports.encodePayloadAsBinary = exports.decodePayload = exports.encodePayload = exports.decodeBase64Packet = exports.decodePacket = exports.encodeBase64Packet = exports.encodePacket = exports.packets = exports.protocol = void 0;\r\n/**\r\n * Module dependencies.\r\n */\r\nvar utf8 = require('./utf8');\r\n/**\r\n * Current protocol version.\r\n */\r\nexports.protocol = 3;\r\nconst hasBinary = (packets) => {\r\n    for (const packet of packets) {\r\n        if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\r\n/**\r\n * Packet types.\r\n */\r\nexports.packets = {\r\n    open: 0 // non-ws\r\n    ,\r\n    close: 1 // non-ws\r\n    ,\r\n    ping: 2,\r\n    pong: 3,\r\n    message: 4,\r\n    upgrade: 5,\r\n    noop: 6\r\n};\r\nvar packetslist = Object.keys(exports.packets);\r\n/**\r\n * Premade error packet.\r\n */\r\nvar err = { type: 'error', data: 'parser error' };\r\nconst EMPTY_BUFFER = Buffer.concat([]);\r\n/**\r\n * Encodes a packet.\r\n *\r\n *     <packet type id> [ <data> ]\r\n *\r\n * Example:\r\n *\r\n *     5hello world\r\n *     3\r\n *     4\r\n *\r\n * Binary is encoded in an identical principle\r\n *\r\n * @api private\r\n */\r\nfunction encodePacket(packet, supportsBinary, utf8encode, callback) {\r\n    if (typeof supportsBinary === 'function') {\r\n        callback = supportsBinary;\r\n        supportsBinary = null;\r\n    }\r\n    if (typeof utf8encode === 'function') {\r\n        callback = utf8encode;\r\n        utf8encode = null;\r\n    }\r\n    if (Buffer.isBuffer(packet.data)) {\r\n        return encodeBuffer(packet, supportsBinary, callback);\r\n    }\r\n    else if (packet.data && (packet.data.buffer || packet.data) instanceof ArrayBuffer) {\r\n        return encodeBuffer({ type: packet.type, data: arrayBufferToBuffer(packet.data) }, supportsBinary, callback);\r\n    }\r\n    // Sending data as a utf-8 string\r\n    var encoded = exports.packets[packet.type];\r\n    // data fragment is optional\r\n    if (undefined !== packet.data) {\r\n        encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);\r\n    }\r\n    return callback('' + encoded);\r\n}\r\nexports.encodePacket = encodePacket;\r\n;\r\n/**\r\n * Encode Buffer data\r\n */\r\nfunction encodeBuffer(packet, supportsBinary, callback) {\r\n    if (!supportsBinary) {\r\n        return encodeBase64Packet(packet, callback);\r\n    }\r\n    var data = packet.data;\r\n    var typeBuffer = Buffer.allocUnsafe(1);\r\n    typeBuffer[0] = exports.packets[packet.type];\r\n    return callback(Buffer.concat([typeBuffer, data]));\r\n}\r\n/**\r\n * Encodes a packet with binary data in a base64 string\r\n *\r\n * @param {Object} packet, has `type` and `data`\r\n * @return {String} base64 encoded message\r\n */\r\nfunction encodeBase64Packet(packet, callback) {\r\n    var data = Buffer.isBuffer(packet.data) ? packet.data : arrayBufferToBuffer(packet.data);\r\n    var message = 'b' + exports.packets[packet.type];\r\n    message += data.toString('base64');\r\n    return callback(message);\r\n}\r\nexports.encodeBase64Packet = encodeBase64Packet;\r\n;\r\n/**\r\n * Decodes a packet. Data also available as an ArrayBuffer if requested.\r\n *\r\n * @return {Object} with `type` and `data` (if any)\r\n * @api private\r\n */\r\nfunction decodePacket(data, binaryType, utf8decode) {\r\n    if (data === undefined) {\r\n        return err;\r\n    }\r\n    var type;\r\n    // String data\r\n    if (typeof data === 'string') {\r\n        type = data.charAt(0);\r\n        if (type === 'b') {\r\n            return decodeBase64Packet(data.substr(1), binaryType);\r\n        }\r\n        if (utf8decode) {\r\n            data = tryDecode(data);\r\n            if (data === false) {\r\n                return err;\r\n            }\r\n        }\r\n        if (Number(type) != type || !packetslist[type]) {\r\n            return err;\r\n        }\r\n        if (data.length > 1) {\r\n            return { type: packetslist[type], data: data.substring(1) };\r\n        }\r\n        else {\r\n            return { type: packetslist[type] };\r\n        }\r\n    }\r\n    // Binary data\r\n    if (binaryType === 'arraybuffer') {\r\n        // wrap Buffer/ArrayBuffer data into an Uint8Array\r\n        var intArray = new Uint8Array(data);\r\n        type = intArray[0];\r\n        return { type: packetslist[type], data: intArray.buffer.slice(1) };\r\n    }\r\n    if (data instanceof ArrayBuffer) {\r\n        data = arrayBufferToBuffer(data);\r\n    }\r\n    type = data[0];\r\n    return { type: packetslist[type], data: data.slice(1) };\r\n}\r\nexports.decodePacket = decodePacket;\r\n;\r\nfunction tryDecode(data) {\r\n    try {\r\n        data = utf8.decode(data, { strict: false });\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n    return data;\r\n}\r\n/**\r\n * Decodes a packet encoded in a base64 string.\r\n *\r\n * @param {String} base64 encoded message\r\n * @return {Object} with `type` and `data` (if any)\r\n */\r\nfunction decodeBase64Packet(msg, binaryType) {\r\n    var type = packetslist[msg.charAt(0)];\r\n    var data = Buffer.from(msg.substr(1), 'base64');\r\n    if (binaryType === 'arraybuffer') {\r\n        var abv = new Uint8Array(data.length);\r\n        for (var i = 0; i < abv.length; i++) {\r\n            abv[i] = data[i];\r\n        }\r\n        // @ts-ignore\r\n        data = abv.buffer;\r\n    }\r\n    return { type: type, data: data };\r\n}\r\nexports.decodeBase64Packet = decodeBase64Packet;\r\n;\r\n/**\r\n * Encodes multiple messages (payload).\r\n *\r\n *     <length>:data\r\n *\r\n * Example:\r\n *\r\n *     11:hello world2:hi\r\n *\r\n * If any contents are binary, they will be encoded as base64 strings. Base64\r\n * encoded strings are marked with a b before the length specifier\r\n *\r\n * @param {Array} packets\r\n * @api private\r\n */\r\nfunction encodePayload(packets, supportsBinary, callback) {\r\n    if (typeof supportsBinary === 'function') {\r\n        callback = supportsBinary;\r\n        supportsBinary = null;\r\n    }\r\n    if (supportsBinary && hasBinary(packets)) {\r\n        return encodePayloadAsBinary(packets, callback);\r\n    }\r\n    if (!packets.length) {\r\n        return callback('0:');\r\n    }\r\n    function encodeOne(packet, doneCallback) {\r\n        encodePacket(packet, supportsBinary, false, function (message) {\r\n            doneCallback(null, setLengthHeader(message));\r\n        });\r\n    }\r\n    map(packets, encodeOne, function (err, results) {\r\n        return callback(results.join(''));\r\n    });\r\n}\r\nexports.encodePayload = encodePayload;\r\n;\r\nfunction setLengthHeader(message) {\r\n    return message.length + ':' + message;\r\n}\r\n/**\r\n * Async array map using after\r\n */\r\nfunction map(ary, each, done) {\r\n    const results = new Array(ary.length);\r\n    let count = 0;\r\n    for (let i = 0; i < ary.length; i++) {\r\n        each(ary[i], (error, msg) => {\r\n            results[i] = msg;\r\n            if (++count === ary.length) {\r\n                done(null, results);\r\n            }\r\n        });\r\n    }\r\n}\r\n/*\r\n * Decodes data when a payload is maybe expected. Possible binary contents are\r\n * decoded from their base64 representation\r\n *\r\n * @param {String} data, callback method\r\n * @api public\r\n */\r\nfunction decodePayload(data, binaryType, callback) {\r\n    if (typeof data !== 'string') {\r\n        return decodePayloadAsBinary(data, binaryType, callback);\r\n    }\r\n    if (typeof binaryType === 'function') {\r\n        callback = binaryType;\r\n        binaryType = null;\r\n    }\r\n    if (data === '') {\r\n        // parser error - ignoring payload\r\n        return callback(err, 0, 1);\r\n    }\r\n    var length = '', n, msg, packet;\r\n    for (var i = 0, l = data.length; i < l; i++) {\r\n        var chr = data.charAt(i);\r\n        if (chr !== ':') {\r\n            length += chr;\r\n            continue;\r\n        }\r\n        // @ts-ignore\r\n        if (length === '' || (length != (n = Number(length)))) {\r\n            // parser error - ignoring payload\r\n            return callback(err, 0, 1);\r\n        }\r\n        msg = data.substr(i + 1, n);\r\n        if (length != msg.length) {\r\n            // parser error - ignoring payload\r\n            return callback(err, 0, 1);\r\n        }\r\n        if (msg.length) {\r\n            packet = decodePacket(msg, binaryType, false);\r\n            if (err.type === packet.type && err.data === packet.data) {\r\n                // parser error in individual packet - ignoring payload\r\n                return callback(err, 0, 1);\r\n            }\r\n            var more = callback(packet, i + n, l);\r\n            if (false === more)\r\n                return;\r\n        }\r\n        // advance cursor\r\n        i += n;\r\n        length = '';\r\n    }\r\n    if (length !== '') {\r\n        // parser error - ignoring payload\r\n        return callback(err, 0, 1);\r\n    }\r\n}\r\nexports.decodePayload = decodePayload;\r\n;\r\n/**\r\n *\r\n * Converts a buffer to a utf8.js encoded string\r\n *\r\n * @api private\r\n */\r\nfunction bufferToString(buffer) {\r\n    var str = '';\r\n    for (var i = 0, l = buffer.length; i < l; i++) {\r\n        str += String.fromCharCode(buffer[i]);\r\n    }\r\n    return str;\r\n}\r\n/**\r\n *\r\n * Converts a utf8.js encoded string to a buffer\r\n *\r\n * @api private\r\n */\r\nfunction stringToBuffer(string) {\r\n    var buf = Buffer.allocUnsafe(string.length);\r\n    for (var i = 0, l = string.length; i < l; i++) {\r\n        buf.writeUInt8(string.charCodeAt(i), i);\r\n    }\r\n    return buf;\r\n}\r\n/**\r\n *\r\n * Converts an ArrayBuffer to a Buffer\r\n *\r\n * @api private\r\n */\r\nfunction arrayBufferToBuffer(data) {\r\n    // data is either an ArrayBuffer or ArrayBufferView.\r\n    var length = data.byteLength || data.length;\r\n    var offset = data.byteOffset || 0;\r\n    return Buffer.from(data.buffer || data, offset, length);\r\n}\r\n/**\r\n * Encodes multiple messages (payload) as binary.\r\n *\r\n * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number\r\n * 255><data>\r\n *\r\n * Example:\r\n * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers\r\n *\r\n * @param {Array} packets\r\n * @return {Buffer} encoded payload\r\n * @api private\r\n */\r\nfunction encodePayloadAsBinary(packets, callback) {\r\n    if (!packets.length) {\r\n        return callback(EMPTY_BUFFER);\r\n    }\r\n    map(packets, encodeOneBinaryPacket, function (err, results) {\r\n        return callback(Buffer.concat(results));\r\n    });\r\n}\r\nexports.encodePayloadAsBinary = encodePayloadAsBinary;\r\n;\r\nfunction encodeOneBinaryPacket(p, doneCallback) {\r\n    function onBinaryPacketEncode(packet) {\r\n        var encodingLength = '' + packet.length;\r\n        var sizeBuffer;\r\n        if (typeof packet === 'string') {\r\n            sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);\r\n            sizeBuffer[0] = 0; // is a string (not true binary = 0)\r\n            for (var i = 0; i < encodingLength.length; i++) {\r\n                sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);\r\n            }\r\n            sizeBuffer[sizeBuffer.length - 1] = 255;\r\n            return doneCallback(null, Buffer.concat([sizeBuffer, stringToBuffer(packet)]));\r\n        }\r\n        sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);\r\n        sizeBuffer[0] = 1; // is binary (true binary = 1)\r\n        for (var i = 0; i < encodingLength.length; i++) {\r\n            sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);\r\n        }\r\n        sizeBuffer[sizeBuffer.length - 1] = 255;\r\n        doneCallback(null, Buffer.concat([sizeBuffer, packet]));\r\n    }\r\n    encodePacket(p, true, true, onBinaryPacketEncode);\r\n}\r\n/*\r\n * Decodes data when a payload is maybe expected. Strings are decoded by\r\n * interpreting each byte as a key code for entries marked to start with 0. See\r\n * description of encodePayloadAsBinary\r\n\r\n * @param {Buffer} data, callback method\r\n * @api public\r\n */\r\nfunction decodePayloadAsBinary(data, binaryType, callback) {\r\n    if (typeof binaryType === 'function') {\r\n        callback = binaryType;\r\n        binaryType = null;\r\n    }\r\n    var bufferTail = data;\r\n    var buffers = [];\r\n    var i;\r\n    while (bufferTail.length > 0) {\r\n        var strLen = '';\r\n        var isString = bufferTail[0] === 0;\r\n        for (i = 1;; i++) {\r\n            if (bufferTail[i] === 255)\r\n                break;\r\n            // 310 = char length of Number.MAX_VALUE\r\n            if (strLen.length > 310) {\r\n                return callback(err, 0, 1);\r\n            }\r\n            strLen += '' + bufferTail[i];\r\n        }\r\n        bufferTail = bufferTail.slice(strLen.length + 1);\r\n        var msgLength = parseInt(strLen, 10);\r\n        var msg = bufferTail.slice(1, msgLength + 1);\r\n        if (isString)\r\n            msg = bufferToString(msg);\r\n        buffers.push(msg);\r\n        bufferTail = bufferTail.slice(msgLength + 1);\r\n    }\r\n    var total = buffers.length;\r\n    for (i = 0; i < total; i++) {\r\n        var buffer = buffers[i];\r\n        callback(decodePacket(buffer, binaryType, true), i, total);\r\n    }\r\n}\r\nexports.decodePayloadAsBinary = decodePayloadAsBinary;\r\n;\r\n"]},"metadata":{},"sourceType":"script"}